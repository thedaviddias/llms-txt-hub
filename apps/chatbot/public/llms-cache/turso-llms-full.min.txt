# List Audit Logs
Source: https://docs.turso.tech/api-reference/audit-logs/list
GET /v1/organizations/{organizationSlug}/audit-logs
Return the audit logs for the given organization, ordered by the `created_at` field in descending order.
<Warning>Audit Logs are limited to paid plans.</Warning>
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/audit-logs \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Authentication
Source: https://docs.turso.tech/api-reference/authentication
The Turso API uses API tokens to authenticate requests. You can create and revoke API tokens using the [Turso CLI](/cli) and [Authentication API](/api-reference/tokens/create).
API tokens allow access to manage all API resources, including creating and destroying database.
* Use environment variables when working with API tokens.
* Never share your API token in public, including repositories, and CI/CD Actions.
Turso uses Bearer authentication, and requires your API token to be passed with all protected requests in the `Authorization` header:
```bash
Authorization: Bearer TOKEN
```
## Base URL
The Turso API is located at the following URL:
```bash
https://api.turso.tech
```
# Retrieve Database Configuration
Source: https://docs.turso.tech/api-reference/databases/configuration
GET /v1/organizations/{organizationSlug}/databases/{databaseName}/configuration
Retrieve an individual database configuration belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L -X GET 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/configuration' \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Create Database
Source: https://docs.turso.tech/api-reference/databases/create
POST /v1/organizations/{organizationSlug}/databases
Creates a new database in a group for the organization or user.
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "new-database",
"group": "default"
}'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const database = await turso.databases.create("new-database", {
group: "default",
});
```
</RequestExample>
# Generate Database Auth Token
Source: https://docs.turso.tech/api-reference/databases/create-token
POST /v1/organizations/{organizationSlug}/databases/{databaseName}/auth/tokens
Generates an authorization token for the specified database.
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/auth/tokens?expiration=2w&authorization=full-access' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const token = await turso.databases.createToken("my-db", {
expiration: "2w",
authorization: "full-access",
});
```
</RequestExample>
<ResponseExample>
```json
{
"jwt": "TOKEN"
}
```
</ResponseExample>
# Delete Database
Source: https://docs.turso.tech/api-reference/databases/delete
DELETE /v1/organizations/{organizationSlug}/databases/{databaseName}
Delete a database belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L -X DELETE 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const database = await turso.databases.delete("my-db");
```
</RequestExample>
# Invalidate All Database Auth Tokens
Source: https://docs.turso.tech/api-reference/databases/invalidate-tokens
POST /v1/organizations/{organizationSlug}/databases/{databaseName}/auth/rotate
Invalidates all authorization tokens for the specified database.
<Warning>
A short downtime is required to complete the changes.
</Warning>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/auth/rotate' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const response = await turso.databases.rotateTokens("my-db");
```
</RequestExample>
# List Databases
Source: https://docs.turso.tech/api-reference/databases/list
GET /v1/organizations/{organizationSlug}/databases
Returns a list of databases belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/databases \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const databases = await turso.databases.list();
```
</RequestExample>
# List Database Instances
Source: https://docs.turso.tech/api-reference/databases/list-instances
GET /v1/organizations/{organizationSlug}/databases/{databaseName}/instances
Returns a list of instances of a database. Instances are the individual primary or replica databases in each region defined by the group.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/instances \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const instances = await turso.databases.listInstances("my-db");
```
</RequestExample>
# Retrieve Database
Source: https://docs.turso.tech/api-reference/databases/retrieve
GET /v1/organizations/{organizationSlug}/databases/{databaseName}
Returns a database belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const database = await turso.databases.retrieve("my-db");
```
</RequestExample>
# Retrieve Database Instance
Source: https://docs.turso.tech/api-reference/databases/retrieve-instance
GET /v1/organizations/{organizationSlug}/databases/{databaseName}/instances/{instanceName}
Return the individual database instance by name.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/instances/{instanceName} \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const instance = await turso.databases.retrieveInstance(
"my-db",
"instanceName",
);
```
</RequestExample>
# Retrieve Database Stats
Source: https://docs.turso.tech/api-reference/databases/stats
GET /v1/organizations/{organizationSlug}/databases/{databaseName}/stats
Fetch the top queries of a database, including the count of rows read and written.
<RequestExample>
```bash cURL
curl -L -X GET 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/stats' \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Update Database Configuration
Source: https://docs.turso.tech/api-reference/databases/update-configuration
PATCH /v1/organizations/{organizationSlug}/databases/{databaseName}/configuration
Update a database configuration belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L -X PATCH 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/configuration' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"size_limit": "500mb"
}'
```
</RequestExample>
# Upload SQLite Dump
Source: https://docs.turso.tech/api-reference/databases/upload-dump
POST /v1/organizations/{organizationSlug}/databases/dumps
Upload a SQL dump to be used when [creating a new database](/api-reference/databases/create) from seed.
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/dumps' \
-H 'Authorization: Bearer TOKEN' \
-F 'file=@"~/Downloads/dump.sql"'
```
</RequestExample>
# Retrieve Database Usage
Source: https://docs.turso.tech/api-reference/databases/usage
GET /v1/organizations/{organizationSlug}/databases/{databaseName}/usage
Fetch activity usage for a database in a given time period.
<RequestExample>
```bash cURL
curl -L -X GET 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases/{databaseName}/usage?from=2023-01-01T00:00:00Z&to=2023-02-01T00:00:00Z' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const usageStatsWithDate = await turso.databases.usage("my-db");
const usageStatsWithDate = await turso.databases.usage("my-db", {
from: new Date("2023-01-01"),
to: new Date("2023-02-01"),
});
const usageStatsWithString = await turso.databases.usage("my-db", {
from: "2023-01-01T00:00:00Z",
to: "2023-02-01T00:00:00Z",
});
```
</RequestExample>
# Create Group
Source: https://docs.turso.tech/api-reference/groups/create
POST /v1/organizations/{organizationSlug}/groups
Creates a new group for the organization or user.
<Warning>
Creating more than one group is limited to Scaler, Pro and Enterprise plans.
</Warning>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "new-group",
"location": "lhr"
}'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const group = await turso.groups.create("new-group", {
location: "lhr",
extensions: ["vector", "uuid"], // 'all'
});
```
</RequestExample>
# Create Group Auth Token
Source: https://docs.turso.tech/api-reference/groups/create-token
POST /v1/organizations/{organizationSlug}/groups/{groupName}/auth/tokens
Generates an authorization token for the specified group.
<Info>
Tokens cannot be retrieved once created, and cannot be revoked individually.
</Info>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/auth/tokens?expiration=2w&authorization=full-access' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const token = await turso.groups.createToken("default", {
expiration: "2w",
authorization: "full-access",
});
```
</RequestExample>
<ResponseExample>
```json
{
"jwt": "TOKEN"
}
```
</ResponseExample>
# Delete Group
Source: https://docs.turso.tech/api-reference/groups/delete
DELETE /v1/organizations/{organizationSlug}/groups/{groupName}
Delete a group belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L -X DELETE 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const group = await turso.groups.delete("new-group");
```
</RequestExample>
# Invalidate All Group Auth Tokens
Source: https://docs.turso.tech/api-reference/groups/invalidate-tokens
POST /v1/organizations/{organizationSlug}/groups/{groupName}/auth/rotate
Invalidates all authorization tokens for the specified group.
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/auth/rotate' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const response = await turso.groups.invalidateTokens("default");
```
</RequestExample>
# List Groups
Source: https://docs.turso.tech/api-reference/groups/list
GET /v1/organizations/{organizationSlug}/groups
Returns a list of groups belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/groups \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const groups = await turso.groups.list();
```
</RequestExample>
# Retrieve Group
Source: https://docs.turso.tech/api-reference/groups/retrieve
GET /v1/organizations/{organizationSlug}/groups/{groupName}
Returns a group belonging to the organization or user.
<RequestExample>
```bash cURL
curl -L 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const group = await turso.groups.retrieve("default");
```
</RequestExample>
# Transfer Group
Source: https://docs.turso.tech/api-reference/groups/transfer
POST /v1/organizations/{organizationSlug}/groups/{groupName}/transfer
Transfer a group to another organization that you own or a member of.
<Info>
You can only transfer groups to organizations you own or are an admin.
</Info>
<Warning>
Existing database URL and tokens will continue to work, but should update your application to use the new URL and token as soon as possible.
</Warning>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/transfer' \
-H 'Authorization: Bearer TOKEN' \
-d '{
"organization": "new-organization-slug"
}'
```
</RequestExample>
# Unarchive Group
Source: https://docs.turso.tech/api-reference/groups/unarchive
POST /v1/organizations/{organizationSlug}/groups/{groupName}/unarchive
Unarchive a group that has been archived due to inactivity.
<Info>
Databases get archived after 10 days of inactivity for users on a free plan — [learn more](/features/scale-to-zero). You can unarchive inactive groups using the API.
</Info>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/unarchive' \
-H 'Authorization: Bearer TOKEN' \
```
</RequestExample>
# Update Databases in a Group
Source: https://docs.turso.tech/api-reference/groups/update-database-versions
POST /v1/organizations/{organizationSlug}/groups/{groupName}/update
Updates all databases in the group to the latest libSQL version.
<Warning>
This operation causes some amount of downtime to occur during the update process. The version of libSQL server is taken from the latest built docker image.
</Warning>
<RequestExample>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/update' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const database = await turso.groups.update("default");
```
</RequestExample>
# Turso Platform API
Source: https://docs.turso.tech/api-reference/introduction
The Turso API gives you everything needed to manage your organization and its members, groups, databases, and API tokens.
If you want to programatically create and manage databases, either for building a platform where you provide SQLite databases to your users or have a per-user SQLite database architecture, this is the API to do that.
<CardGroup cols={2}>
<Card title="API Quickstart" icon="play" href="/api-reference/quickstart">
Get started with the Turso API to create your first database.
</Card>
</CardGroup>
## API Resources
Start integrating the Turso API with your platform in a few simple steps.
<Snippet file="platform-api-links.mdx" />
# Closest Region
Source: https://docs.turso.tech/api-reference/locations/closest-region
GET https://region.turso.io
Returns the closest region to the user's location.
#### Response
<ResponseField name="server" type="string">
The location code for the server responding.
</ResponseField>
<ResponseField name="client" type="string">
The location code for the client request.
</ResponseField>
<RequestExample>
```bash cURL
curl https://region.turso.io
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const { server, client } = await turso.locations.closest();
```
</RequestExample>
<ResponseExample>
```json 200
{
"server": "lhr",
"client": "lhr"
}
```
</ResponseExample>
# List Locations
Source: https://docs.turso.tech/api-reference/locations/list
GET /v1/locations
Returns a list of locations where you can create or replicate databases.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/locations \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const locations = await turso.locations.list();
```
</RequestExample>
# Create Invite
Source: https://docs.turso.tech/api-reference/organizations/invites/create
POST /v1/organizations/{organizationSlug}/invites
Invite a user (who isn't already a Turso user) to an organization.
<Info>
If you want to invite someone who is already a registered Turso user, you can [add them](/api-reference/organizations/members/add) instead.
</Info>
<Info>
You must be an `owner` or `admin` to invite other users. **You can only invite users to a team and not your personal account.**
</Info>
# Delete Invite
Source: https://docs.turso.tech/api-reference/organizations/invites/delete
DELETE /v1/organizations/{organizationSlug}/invites/{email}
Delete an invite for the organization by email.
<RequestExample>
```bash cURL
curl -L -X DELETE https://api.turso.tech/v1/organizations/{organizationSlug}/invites/{email} \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# List Invites
Source: https://docs.turso.tech/api-reference/organizations/invites/list
GET /v1/organizations/{organizationSlug}/invites
Returns a list of invites for the organization.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/invites \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const invites = await turso.organizations.invites("mycompany");
```
</RequestExample>
# List Invoices
Source: https://docs.turso.tech/api-reference/organizations/invoices
GET /v1/organizations/{organizationSlug}/invoices
Returns a list of invoices for the organization.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/invoices \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# List Organizations
Source: https://docs.turso.tech/api-reference/organizations/list
GET /v1/organizations
Returns a list of organizations the authenticated user owns or is a member of.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const organizations = await turso.organizations.list();
```
</RequestExample>
# Add Member
Source: https://docs.turso.tech/api-reference/organizations/members/add
POST /v1/organizations/{organizationSlug}/members
Add an existing Turso user to an organization.
<Info>
If you want to add someone who is not a registered Turso user, you can [create an invite](/api-reference/organizations/invites/create) instead.
</Info>
<Info>
You must be an `owner` or `admin` to add other members. **You can only add users to a team and not your personal account.**
</Info>
# List Members
Source: https://docs.turso.tech/api-reference/organizations/members/list
GET /v1/organizations/{organizationSlug}/members
Returns a list of members part of the organization.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/members \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const members = await turso.organizations.members("mycompany");
```
</RequestExample>
# Remove Member
Source: https://docs.turso.tech/api-reference/organizations/members/remove
DELETE /v1/organizations/{organizationSlug}/members/{username}
Remove a user from the organization by username.
<RequestExample>
```bash cURL
curl -L -X DELETE https://api.turso.tech/v1/organizations/{organizationSlug}/members/{username} \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const member = await turso.organizations.removeMember("mycompany", "iku");
```
</RequestExample>
# Retrieve Member
Source: https://docs.turso.tech/api-reference/organizations/members/retrieve
GET /v1/organizations/{organizationSlug}/members/{username}
Retrieve details of a specific member in the organization.
<RequestExample>
```bash
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/members/{username} \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Update Member Role
Source: https://docs.turso.tech/api-reference/organizations/members/update
PATCH /v1/organizations/{organizationSlug}/members/{username}
Update the role of an organization member. Only organization admins or owners can perform this action.
<RequestExample>
```bash
curl -L -X PATCH https://api.turso.tech/v1/organizations/{organizationSlug}/members/{username} \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"role": "member"
}'
```
</RequestExample>
# List Plans
Source: https://docs.turso.tech/api-reference/organizations/plans
GET /v1/organizations/{organizationSlug}/plans
Returns a list of available plans and their quotas.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/plans \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Retrieve Organization
Source: https://docs.turso.tech/api-reference/organizations/retrieve
GET /v1/organizations/{organizationSlug}
Retrieve details of a specific organization.
<RequestExample>
```bash
curl -L https://api.turso.tech/v1/organizations/{organizationSlug} \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Current Subscription
Source: https://docs.turso.tech/api-reference/organizations/subscription
GET /v1/organizations/{organizationSlug}/subscription
Returns the current subscription details for the organization.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/subscription \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Update Organization
Source: https://docs.turso.tech/api-reference/organizations/update
PATCH /v1/organizations/{organizationSlug}
Update an organization you own or are a member of.
<RequestExample>
```bash cURL
curl -L -X PATCH https://api.turso.tech/v1/organizations/{organizationSlug} \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"overages": true
}'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const organization = await turso.organizations.update("mycompany", {
overages: true,
});
```
</RequestExample>
# Organization Usage
Source: https://docs.turso.tech/api-reference/organizations/usage
GET /v1/organizations/{organizationSlug}/usage
Fetch current billing cycle usage for an organization.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/organizations/{organizationSlug}/usage \
-H 'Authorization: Bearer TOKEN'
```
</RequestExample>
# Quickstart
Source: https://docs.turso.tech/api-reference/quickstart
Get started with Turso API in a few easy steps.
<Steps>
<Step title="Signup or Login using the Turso CLI">
Make sure to [install the Turso CLI](/cli/installation) if you haven't
already.
<CodeGroup>
```bash Signup
turso auth signup
```
```bash Login
turso auth login
```
</CodeGroup>
</Step>
<Step title="Retrieve your account or organization slug">
The Platform API can be used with your personal account or with an organization. You'll need the obtain the `slug` of your account or organization using using the Turso CLI:
```bash
turso org list
```
</Step>
<Step title="Create a new Platform API Token">
Now create a new API Token using the Turso CLI:
```bash
turso auth api-tokens mint quickstart
```
<Info>
Make sure to save the token somewhere safe. We'll need it next.
</Info>
</Step>
<Step title="Fetch available Locations">
Before we can create a group or database in a specific region, we'll need to fetch the list of available regions:
<CodeGroup>
```bash cURL
curl -L 'https://api.turso.tech/v1/locations' \
-H 'Authorization: Bearer TOKEN' \
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const locations = await turso.locations.list();
```
</CodeGroup>
<br />
<Info>
The `organizationSlug` is the name of your organization or personal account.
</Info>
</Step>
<Step title="Create a Group">
All databases belong to a group that can exist in one or more locations.
Begin by creating a group, giving it a `name` and primary `location`:
<CodeGroup>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "default",
"location": "lhr"
}'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const group = await turso.groups.addLocation("default", "lhr");
```
</CodeGroup>
</Step>
<Step title="Create a Database">
Now create your first database in the group you created above:
<CodeGroup>
```bash cURL
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "my-db",
"group": "default"
}'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const database = await turso.databases.create("my-db", "ams");
```
</CodeGroup>
</Step>
<Step title="Connect to your database">
You now have a database, distributed across multiple regions that you can connect to using one of the official or experimental SDKs:
<Snippet file="all-sdks.mdx" />
</Step>
</Steps>
# Errors
Source: https://docs.turso.tech/api-reference/response-codes
The Turso API will respond with an HTTP status code, and in the event of an error, return an error message in the response body.
| Code  | Description                                                      |
| ----- | ---------------------------------------------------------------- |
| `200` | `OK` — Successful request                                        |
| `401` | `Unauthorized` — Invalid or expired auth token                   |
| `402` | `Payment required` — Check you have an active subscription       |
| `403` | `Forbidden` — You do not have permission to access this resource |
| `409` | `Conflict` — Resource already exists                             |
# Create API Token
Source: https://docs.turso.tech/api-reference/tokens/create
POST /v1/auth/api-tokens/{tokenName}
Returns a new API token belonging to a user.
<Warning>
The `token` in the response is never revealed again. Store this somewhere safe, and never share or commit it to source control.
</Warning>
<RequestExample>
```bash cURL
curl -L -X POST https://api.turso.tech/v1/auth/api-tokens/{tokenName} \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const apiToken = await turso.apiTokens.create("my-token");
```
</RequestExample>
# List API Tokens
Source: https://docs.turso.tech/api-reference/tokens/list
GET /v1/auth/api-tokens
Returns a list of API tokens belonging to a user.
<RequestExample>
```bash cURL
curl -L https://api.turso.tech/v1/auth/api-tokens \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const apiTokens = await turso.apiTokens.list();
```
</RequestExample>
# Revoke API Token
Source: https://docs.turso.tech/api-reference/tokens/revoke
DELETE /v1/auth/api-tokens/{tokenName}
Revokes the provided API token belonging to a user.
<RequestExample>
```bash cURL
curl -L -X DELETE 'https://api.turso.tech/v1/auth/api-tokens/{tokenName}' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const response = await turso.apiTokens.revoke("my-token");
```
</RequestExample>
# Validate API Token
Source: https://docs.turso.tech/api-reference/tokens/validate
GET /v1/auth/validate
Validates an API token belonging to a user.
<RequestExample>
```bash cURL
curl -L 'https://api.turso.tech/v1/auth/validate' \
-H 'Authorization: Bearer TOKEN'
```
```ts Node.js
import { createClient } from "@tursodatabase/api";
const turso = createClient({
org: "...",
token: "",
});
const response = await turso.apiTokens.validate("...");
```
</RequestExample>
# auth api-tokens list
Source: https://docs.turso.tech/cli/auth/api-tokens/list
To list all API tokens for the current organization, run the following command:
```bash
turso auth api-tokens list
```
# auth api-tokens mint
Source: https://docs.turso.tech/cli/auth/api-tokens/mint
To create a new API token for the current organization, run the following command:
```bash
turso auth api-tokens mint <api-token-name>
```
# auth api-tokens revoke
Source: https://docs.turso.tech/cli/auth/api-tokens/revoke
To revoke an API token for the current organization, run the following command:
```bash
turso auth api-tokens revoke <api-token-name>
```
# auth login
Source: https://docs.turso.tech/cli/auth/login
To authenticate the Turso CLI with your account, run the following command:
```bash
turso auth login
```
<Note>
If you're using Windows with WSL or a remote CI/CD environment, pass the --headless flag.
</Note>
## Flags
| Flag         | Description                                                       |
| ------------ | ----------------------------------------------------------------- |
| `--headless` | Useful when the CLI can't interact with the system's web browser. |
# auth logout
Source: https://docs.turso.tech/cli/auth/logout
To logout of the Turso CLI, run the following command:
```bash
turso auth logout
```
## Flags
| Flag        | Description                                   |
| ----------- | --------------------------------------------- |
| `-a, --all` | Invalidate all sessions for the current user. |
# auth signup
Source: https://docs.turso.tech/cli/auth/signup
To sign up for a new Turso account using the CLI, run the following command:
```bash
turso auth signup
```
<Note>
If you're using Windows with WSL or a remote CI/CD environment, pass the --headless flag.
</Note>
## Flags
| Flag         | Description                                                       |
| ------------ | ----------------------------------------------------------------- |
| `--headless` | Useful when the CLI can't interact with the system's web browser. |
# auth token
Source: https://docs.turso.tech/cli/auth/token
You can obtain your current API token that is used to authenticate with the Turso Platform API by running the following command:
```bash
turso auth token
```
# auth whoami
Source: https://docs.turso.tech/cli/auth/whoami
You can obtain the username for the currently logged in user by running the following command:
```bash
turso auth whoami
```
# Authentication
Source: https://docs.turso.tech/cli/authentication
## `login`
The Turso CLI uses an access token to authenticate with Turso. You can login using the command:
```bash
turso auth login
```
This will open a browser window, asking you to log into your account with GitHub.
<Note>
If you're using Windows with WSL or a remote CI/CD environment, pass the `--headless` flag.
</Note>
Once you're logged in, you can manage your account and databases. You can explore all of the commands via the docs, or by using the `--help` flag for each subcommand:
```bash
turso
```
<Info>
The Turso CLI requires you to reauthenticate after one week. Don't share your token.
</Info>
## `signup`
If you're new to Turso, you can create an account using the Turso CLI:
```bash
turso auth signup
```
## `logout`
You can logout of the Turso CLI using the `logout` command:
```bash
turso auth logout
```
# contact bookmeeting
Source: https://docs.turso.tech/cli/contact/bookmeeting
You can book a meeting with the Turso team to discuss your project and requirements using the following command:
```bash
turso contact bookmeeting
```
<Info>
You will be redirected to a webpage where you can select a date and time for the meeting.
</Info>
# contact feedback
Source: https://docs.turso.tech/cli/contact/feedback
You can send feedback to the Turso team by using the following command:
```bash
turso contact feedback
```
# db create
Source: https://docs.turso.tech/cli/db/create
You can create a new database in a specific group using the following command:
```bash
turso db create [database-name]
```
<Info>
The `[database-name]` argument is optional. If you don't provide a name, the Turso team will use the name of your project.
</Info>
<Info>
If you have more than one group, you will need to pass the `--group` flag.
</Info>
## Flags
| Flag                  | Description                                                                                                                                                                                                                           |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--enable-extensions` | Enables experimental support for SQLite extensions.                                                                                                                                                                                   |
| `--from-csv`          | Create the database from a csv file.                                                                                                                                                                                                  |
| `--csv-table-name`    | Name of the table in the csv file.                                                                                                                                                                                                    |
| `--from-db`           | Select another database to copy data from.                                                                                                                                                                                            |
| `--timestamp`         | Set a point in time in the past to copy data from the selected database.<br /><br />Must be used with the 'from-db' flag. Must be in [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) format like '2023-09-29T10:16:13-03:00' |
| `--from-dump`         | Create the database from a local SQLite dump.                                                                                                                                                                                         |
| `--from-dump-url`     | Create the database from a remote SQLite dump.                                                                                                                                                                                        |
| `--from-file`         | Create the database from a local SQLite3-compatible file.                                                                                                                                                                             |
| `--group`             | Create the database in the specified group.                                                                                                                                                                                           |
| `--size-limit`        | The maximum size of the database in bytes. Values with units are also accepted, e.g. 1mb, 256mb, 1gb.                                                                                                                                 |
| `--canary`            | Use database canary build.                                                                                                                                                                                                            |
| `-w`, `--wait`        | Wait for the database to be ready to receive requests.                                                                                                                                                                                |
| `-h`, `--help`        | Get help for create.                                                                                                                                                                                                                  |
## Examples
The examples below outline the most common use cases for the `db create` command.
### Create database in a specific group
You can create a new database in a specific group using the `--group` flag:
```bash
turso db create [database-name] --group <group-name>
```
### Create database from SQLite file
You can create a new Turso database from an existing SQLite file using the `--from-file` flag:
```bash
turso db create [database-name] --from-file ./path/to/file.db
```
<Info>
The file size is limited to 2GB.
</Info>
### Create database from SQLite dump
You can create a new database using the output of `.dump` using the `--from-dump` flag:
```bash
turso db create [database-name] --from-dump ./path/to/dump.sql
```
### Create database from another existing database
You can create a new Turso database from an existing database using the `--from-db` flag:
```bash
turso db create [database-name] --from-db <existing-database-name>
```
### Create database from a point in time
You can create a new Turso database from an existing database at a specific point in time using the `--from-db` and `--timestamp` flags:
```bash
turso db create [database-name] --from-db <existing-database-name> --timestamp 2024-01-01T10:10:10-10:00
```
### Create database from a CSV file
You can create a new Turso database from a CSV file using the `--from-csv` flag:
```bash
turso db create [database-name] --from-csv ./path/to/file.csv --csv-table-name <desired-table-name>
```
### Create a database with extensions enabled
You can create a database with experimental support for SQLite [extensions](/libsql#extensions) using the `--enable-extensions` flag:
```bash
turso db create [database-name] --enable-extensions
```
<Note>
Using `--enable-extensions` will enable extensions on all databases in the group.
</Note>
# db destroy
Source: https://docs.turso.tech/cli/db/destroy
You can destroy a database by using the following command:
```bash
turso db destroy <database-name> [flags]
```
## Flags
| Flag          | Description                            |
| ------------- | -------------------------------------- |
| `-y`, `--yes` | Confirms the destruction the database. |
# db inspect
Source: https://docs.turso.tech/cli/db/inspect
You can inspect the usage of a database, including the total space used, rows read and written with the following command:
```bash
turso db inspect <database-name>
```
## Flags
| Flag        | Description                                                          |
| ----------- | -------------------------------------------------------------------- |
| `--queries` | Show database query statistics.                                      |
| `--verbose` | Show detailed information, including the location and instance type. |
## Examples
### Top Queries
You can fetch the most executed, resource-intensive SQL statements that have been run against your database using the Turso CLI:
<CodeGroup>
```bash Command
turso db inspect <database-name> --queries
```
```bash Response
SELECT * FROM Orders WHERE Status = 'Pending';
SELECT COUNT(*), CustomerID FROM Orders GROUP BY CustomerID HAVING COUNT(*) > 5;
SELECT Orders.OrderID, Customers.CustomerName FROM Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
UPDATE Products SET Price = Price * 1.10 WHERE Category = 'Electronics';
```
</CodeGroup>
# db list
Source: https://docs.turso.tech/cli/db/list
You can obtain a list of all databases for the current user or organization by running the following command:
```bash
turso db list
```
## Flags
| Flag                   | Description                |
| ---------------------- | -------------------------- |
| `--group <group-name>` | Filter databases by group. |
# db locations
Source: https://docs.turso.tech/cli/db/locations
You can fetch a list of [supported locations](/cloud-providers#locations) where databases can be located by running the following command:
```bash
turso db locations
```
## Flags
| Flag                     | Description                                                               |
| ------------------------ | ------------------------------------------------------------------------- |
| `-l`, `--show-latencies` | Display latencies from your current location to each of Turso's locations |
# db shell
Source: https://docs.turso.tech/cli/db/shell
You can connect directly to a Turso database by using the following command:
```bash
turso db shell <database-name> [sql] [flags]
```
## Flags
| Flag                         | Description                                        |
| ---------------------------- | -------------------------------------------------- |
| `--instance <instance>`      | Connect to the specified database instance.        |
| `--location <location-code>` | Connect to the database at the specified location. |
| `--proxy <url>`              | The proxy to use when connecting to the database.  |
## Examples
### Execute SQL
You can execute SQL directly against a database using the shell:
```bash
turso db shell <database-name> "SELECT * FROM users"
```
### Database dump
You can dump the contents of a Turso database using the following command:
```bash
turso db shell <database-name> .dump > dump.sql
```
<Info>
The `.dump` can be used to rebuild a database and doesn't contain any libSQL or SQLite internal tables.
</Info>
### Load from dump
You can load a dump file into a new database using the following command:
```bash
turso db shell <database-name> < dump.sql
```
### Shell with libSQL server
If you're using `turso dev` locally, you can use the shell by providing the URL to your database:
```bash
turso db shell http://127.0.0.1:8080
```
# db show
Source: https://docs.turso.tech/cli/db/show
You can obtain details about the database, including the name, ID, libSQL server version, group, size and location.
```bash
turso db show <database-name> [flags]
```
You can also obtain the different URLs for the database using the following:
## Flags
| Flag         | Description                              |
| ------------ | ---------------------------------------- |
| `--url`      | Show URL for the database HTTP API.      |
| `--http-url` | Show HTTP URL for the database HTTP API. |
# db tokens create
Source: https://docs.turso.tech/cli/db/tokens/create
You can create a new token that can be used to connect to one database using the command:
```bash
turso db tokens create <database-name> [flags]
```
## Flags
| Flag                 | Description                                                                     |
| -------------------- | ------------------------------------------------------------------------------- |
| `-e`, `--expiration` | The expiration time for a token, can be `never` or a value in days, e.g. `7d` . |
| `-r`, `--read-only`  | Restrict the token to read only access.                                         |
## Examples
The examples below outline the most common use cases for the `db tokens create` command.
### Create a token with read only access
You can create a token with read only access to a database using the following command:
```bash
turso db tokens create <database-name> --read-only
```
### Create a token with a specific expiration time
You can create a token with a specific expiration time using the following command:
```bash
turso db tokens create <database-name> --expiration 7d3h2m1s
```
# db tokens invalidate
Source: https://docs.turso.tech/cli/db/tokens/invalidate
You can invalidate all tokens for a database by running the following command:
```bash
turso db tokens invalidate <database-name> [flags]
```
## Flags
| Flag          | Description                                          |
| ------------- | ---------------------------------------------------- |
| `-y`, `--yes` | Confirms the invalidation of all existing db tokens. |
<Warning>
All tokens in the group that provided database belongs will also be invalidated. This means that all existing tokens will no longer be valid and will need to be regenerated.
</Warning>
# dev
Source: https://docs.turso.tech/cli/dev
# group create
Source: https://docs.turso.tech/cli/group/create
You can create a new group of databases. Groups belong to a primary region.
```bash
turso group create <group-name> [flags]
```
<Warning>
Creating more than one group is limited to Scaler, Pro and Enterprise plans.
</Warning>
<Info>
Turso will automatically detect the closest region and use that as the primary region. You can override this by specifying the `--location` flag.
</Info>
## Flags
| Flag           | Description                                                                 |
| -------------- | --------------------------------------------------------------------------- |
| `--canary`     | Use database canary build.                                                  |
| `--location`   | Create the group in the specified priary location using a three-digit code. |
| `-w`, `--wait` | Wait for group to be ready before exiting.                                  |
# group destroy
Source: https://docs.turso.tech/cli/group/destroy
You can destroy a group and all of its databases using the following command:
```bash
turso group destroy <group-name> [flags]
```
## Flags
| Flag          | Description                                                      |
| ------------- | ---------------------------------------------------------------- |
| `-y`, `--yes` | Confirms destroying the group, with all locations and databases. |
# group list
Source: https://docs.turso.tech/cli/group/list
You can obtain a list of all groups by using the following command:
```bash
turso group list
```
# group tokens create
Source: https://docs.turso.tech/cli/group/tokens/create
You can create a new token that can be used to connect to any database in the group using the command:
```bash
turso group tokens create <group-name> [flags]
```
## Flags
| Flag                 | Description                                                                     |
| -------------------- | ------------------------------------------------------------------------------- |
| `-e`, `--expiration` | The expiration time for a token, can be `never` or a value in days, e.g. `7d` . |
| `-r`, `--read-only`  | Restrict the token to read only access.                                         |
## Examples
The examples below outline the most common use cases for the `group tokens create` command.
### Create a token with read only access
You can create a token with read only access using the command:
```bash
turso group tokens create <group-name> --read-only
```
### Create a token with a specific expiration time
You can create a token with a specific expiration time using the command:
```bash
turso group tokens create <group-name> --expiration 7d
```
# group tokens invalidate
Source: https://docs.turso.tech/cli/group/tokens/invalidate
You can invalidate all tokens for a group by running the command:
```bash
turso group tokens invalidate <group-name> [flags]
```
## Flags
| Flag          | Description                                             |
| ------------- | ------------------------------------------------------- |
| `-y`, `--yes` | Confirms the invalidation of all existing group tokens. |
# group transfer
Source: https://docs.turso.tech/cli/group/transfer
You can transfer a group (including its databases) to an organization you're an admin or owner of using the following command:
```bash
turso group transfer <group-name> <organization-name> [flags]
```
<Warning>
Existing database URL and tokens will continue to work, but should update your application to use the new URL and token as soon as possible.
</Warning>
## Flags
| Flag          | Description                                  |
| ------------- | -------------------------------------------- |
| `-y`, `--yes` | Confirms the transfer to a new organization. |
# group unarchive
Source: https://docs.turso.tech/cli/group/unarchive
You can unarchive inactive databases by running the following command:
```bash
turso group unarchive <group-name>
```
<Info>
Databases get archived after 10 days of inactivity for users on a free plan — [learn more](/features/scale-to-zero).
</Info>
# group update
Source: https://docs.turso.tech/cli/group/update
You can update the group, including all databases the following command:
```bash
turso group update <group-name> [flags]
```
## Flags
| Flag                  | Description                                                                         |
| --------------------- | ----------------------------------------------------------------------------------- |
| `--extensions string` | Enable extensions by passing `all` or `none`.                                       |
| `--version string`    | Specify the version of the group to update to. Values include `latest` or `canary`. |
| `-y`, `--yes`         | Skip confirmation prompt and confirm.                                               |
## Examples
### Update a group to enable all extensions
You can update a group and all its databases to enable `all` extensions:
```bash
turso group update <group-name> --extensions all
```
# Headless Mode
Source: https://docs.turso.tech/cli/headless-mode
The Turso CLI will automatically attempt to open a browser, or wait for further instructions when interacting with various commands.
You can opt out of this behaviour by passing the `--headless` flag with operations:
```bash
turso auth login --headless
```
<Note>
If you're using Windows with WSL or a remote CI/CD environment, pass the `--headless` flag.
</Note>
# Help
Source: https://docs.turso.tech/cli/help
You can always find a summary of all commands by running the following command:
```bash
turso help
```
You can also find out more about each command, as well as any required or optional arguments by passing the `--help` flag to the command:
```bash
turso auth --help
turso db create --help
```
If you require support integrating Turso into your project, [we can help](/support).
# Installation
Source: https://docs.turso.tech/cli/installation
Learn how to install the Turso CLI on Mac, Linux and Windows.
## macOS
To install the Turso CLI on macOS, we recommend that you use Homebrew:
```bash
brew install tursodatabase/tap/turso
```
If you don't use Homebrew, you can use the following command to execute a shell script that installs the CLI:
```bash
curl -sSfL https://get.tur.so/install.sh | bash
```
## Linux
Run the following command to execute a shell script that installs the CLI:
```bash
curl -sSfL https://get.tur.so/install.sh | bash
```
## Windows
Installing the Turso CLI on Windows requires that you have [WSL](https://learn.microsoft.com/en-us/windows/wsl/install) installed.
Once WSL is installed, run the following in PowerShell:
```bash
wsl
```
You can then execute the script to install the Turso CLI:
```bash
curl -sSfL https://get.tur.so/install.sh | bash
```
## Verify installation
You must open a new shell to verify the installation with the following command:
```bash
turso
```
# Introduction
Source: https://docs.turso.tech/cli/introduction
The Turso CLI gives you everything you need from the command line to manage your database, API tokens, inviting users, and launching the database shell. If you're waiting for a migration to run, there's also a relax command.
You can also programmatically manage your Turso account, including groups, databases, organizations and invites using the [Platform API](/api-reference).
<Steps>
<Step title="Install">
Begin by installing the Turso CLI:
<CodeGroup>
```bash macOS
brew install tursodatabase/tap/turso
```
```bash Linux
curl -sSfL https://get.tur.so/install.sh | bash
```
```bash Windows (WSL)
curl -sSfL https://get.tur.so/install.sh | bash
```
</CodeGroup>
</Step>
<Step title="Authenticate">
Now signup or login:
<CodeGroup>
```bash Signup
turso auth signup
```
```bash Login
turso auth login
```
```bash Signup (WSL)
turso auth signup --headless
```
```bash Login (WSL)
turso auth login --headless
```
</CodeGroup>
</Step>
<Step title="Operate">
The Turso CLI provides the following commands:
| Command                     | Description                                                          |
| --------------------------- | -------------------------------------------------------------------- |
| [`auth`](/cli/auth)         | Authenticate and manage API tokens.                                  |
| [`contact`](/cli/contact)   | Submit your feedback, ideas and create a meeting with the team.      |
| [`db`](/cli/db)             | Create and manage databases, access tokens and connect to the shell. |
| `dev`                       | Run Turso [locally](/local-development) for development.             |
| [`group`](/cli/group)       | Create groups for databases with a shared location.                  |
| [`org`](/cli/org)           | Manage billing and invite members.                                   |
| [`plan`](/cli/plan)         | `overages`, `select`, `show`, `upgrade`                              |
| [`quickstart`](/quickstart) | Get started with Turso in 5 minutes.                                 |
| `relax`                     | Take some time out and relax with Turso.                             |
| `update`                    | Update to the Turso CLI to the latest version with one command.      |
</Step>
</Steps>
# org billing
Source: https://docs.turso.tech/cli/org/billing
To open the billing portal for your organization:
```bash
turso org billing
```
# org create
Source: https://docs.turso.tech/cli/org/create
To create a new organization that you own, run the following command:
```bash
turso org create <name>
```
<Info>
You will be asked to add a payment method and subscribe to the Scaler plan to successfully create a new organization.
</Info>
# destroy
Source: https://docs.turso.tech/cli/org/destroy
To delete an existing organization that you own, run the following command:
```bash
turso org destroy <organization-slug>
```
<Info>
You will need to transfer or delete any existing projects before you can delete an organization. Users cannot also destroy the a personal account or active organization.
</Info>
# org list
Source: https://docs.turso.tech/cli/org/list
To list organizations of which you are the owner or a member, run the following command:
```bash
turso org list
```
# org members add
Source: https://docs.turso.tech/cli/org/members/add
To add an existing Turso user as a member to the current active organization, run the following command:
```bash
turso org members add <username> [flags]
```
## Flags
| Flag            | Description               |
| --------------- | ------------------------- |
| `-a`, `--admin` | Add the user as an admin. |
# org members invite
Source: https://docs.turso.tech/cli/org/members/invite
To invite someone who isn't already a Turso user to the current active organization, run the following command:
```bash
turso org members invite <email> [flags]
```
## Flags
| Flag            | Description               |
| --------------- | ------------------------- |
| `-a`, `--admin` | Add the user as an admin. |
# org members list
Source: https://docs.turso.tech/cli/org/members/list
To list all members of the current active organization, run the following command:
```bash
turso org members list
```
<Info>
This command is only available to active organizations, use [`org switch`](/cli/org/switch) if you're currently authenticated with your personal account.
</Info>
# org members rm
Source: https://docs.turso.tech/cli/org/members/rm
To remove a member from the current organization, use the following command:
```bash
turso org members rm <username>
```
# org switch
Source: https://docs.turso.tech/cli/org/switch
To switch the current active organization for the CLI, use the following command:
```bash
turso org switch <organization-slug>
```
# plan overages disable
Source: https://docs.turso.tech/cli/plan/overages/disable
You can disable overages for the current repository by running the following command:
```bash
turso plan overages disable
```
<Info>
Any overages that have already been incurred will still be charged.
</Info>
# plan overages enable
Source: https://docs.turso.tech/cli/plan/overages/enable
You can enable overages for the current repository by running the following command:
```bash
turso plan overages enable
```
# plan select
Source: https://docs.turso.tech/cli/plan/select
You can switch your current plan at any time using the command:
```bash
turso plan select
```
<Info>
You will need to add your credit card details to your account before you can upgrade to a paid plan. [Learn more](https://turso.tech/pricing) about pricing.
</Info>
# plan show
Source: https://docs.turso.tech/cli/plan/show
You can show the current plan usage and limits with the command:
```bash
turso plan show
```
# plan upgrade
Source: https://docs.turso.tech/cli/plan/upgrade
You can upgrade your account to a paid plan at any time using the command:
```bash
turso plan upgrade
```
<Info>
You will need to add your credit card details to your account before you can upgrade to a paid plan.
</Info>
# Upgrading
Source: https://docs.turso.tech/cli/upgrading
Update the Turso CLI to the latest version to benefit from all the latest features, and fixes.
## macOS
```bash
brew update
brew upgrade
```
## Linux
```bash
turso update
```
## Windows
```bash
turso update
```
# Cloud Providers
Source: https://docs.turso.tech/cloud-providers
Turso is available on AWS and Fly.
## AWS (Public Beta)
AWS is the default cloud provider for new Turso users. Existing users can create a new [database group](/concepts#groups) on AWS.
| Feature               | Fly   | AWS   |
| --------------------- | ----- | ----- |
| Vector                | ✅     | ✅     |
| File Size Limit       | 100GB | 1GB\* |
| Point-in-time Restore | ✅     | ℹ️    |
| Branching             | ✅     | ✅     |
| Embedded Syncs        | ✅     | ℹ️    |
| Upload SQLite Files   | ✅     | ℹ️    |
| API-Level DB Lock     | ✅     | ℹ️    |
| Extensions            | ✅     | ℹ️    |
| Bring Your Own S3     | ✅     | ℹ️    |
* `*` The file size limit is temporary, and will increase in the future.
* ℹ️ Now available on Pro, coming soon to all plans.
### AWS Locations
| Code        | Location                |
| ----------- | ----------------------- |
| `us-east-1` | US East (N. Virginia)   |
| `us-west-2` | US West (Oregon)        |
| `us-west-1` | US West (N. California) |
| `eu-west-3` | Europe (Paris)          |
## Fly
You can create a [group](#groups) for many databases that share a single location below:
### Fly Locations
| Code  | Location                     |
| ----- | ---------------------------- |
| `ams` | Amsterdam, Netherlands       |
| `arn` | Stockholm, Sweden            |
| `bog` | Bogotá, Colombia             |
| `bos` | Boston, Massachusetts (US)   |
| `cdg` | Paris, France                |
| `den` | Denver, Colorado (US)        |
| `dfw` | Dallas, Texas (US)           |
| `ewr` | Secaucus, NJ (US)            |
| `eze` | Ezeiza, Argentina            |
| `fra` | Frankfurt, Germany           |
| `gdl` | Guadalajara, Mexico          |
| `gig` | Rio de Janeiro, Brazil       |
| `gru` | São Paulo, Brazil            |
| `hkg` | Hong Kong, Hong Kong         |
| `iad` | Ashburn, Virginia (US)       |
| `jnb` | Johannesburg, South Africa   |
| `lax` | Los Angeles, California (US) |
| `lhr` | London, United Kingdom       |
| `mad` | Madrid, Spain                |
| `mia` | Miami, Florida (US)          |
| `nrt` | Tokyo, Japan                 |
| `ord` | Chicago, Illinois (US)       |
| `otp` | Bucharest, Romania           |
| `qro` | Querétaro, Mexico            |
| `scl` | Santiago, Chile              |
| `sea` | Seattle, Washington (US)     |
| `sin` | Singapore, Singapore         |
| `sjc` | San Jose, California (US)    |
| `syd` | Sydney, Australia            |
| `waw` | Warsaw, Poland               |
| `yul` | Montreal, Canada             |
| `yyz` | Toronto, Canada              |
<Info>
You can fetch the list of supported locations as JSON when building with the [Platform API](/api-reference/locations) or using the [Turso CLI](/cli/db/locations).
</Info>
## Things to know
* You can't transfer databases between cloud providers.
* AWS restrictions are temporary, and will be lifted incremently during the beta.
# Durability Guarantees
Source: https://docs.turso.tech/cloud/durability
The following are the durability guarantees provided by the Turso Cloud platform for users who registered or upgraded **after March 17, 2025**:
|                   | Durability    | Added commit latency |
| ----------------- | ------------- | -------------------- |
| **Free**          | 99.999999999% | up to 100ms          |
| **Developer**     | 99.999999999% | up to 50ms           |
| **Scaler**        | 99.999999999% | up to 25ms           |
| **Pro and above** | 99.999999999% | up to 10ms           |
For all Turso AWS regions, we employ a diskless architecture where data is backed by a combination of S3-Express One Zone and S3.
Commits are only acknowledged once data is safely stored in either S3 or S3-express. Compute nodes can come and go at any time, and local disks act as a local cache. Therefore, we can provide the same durability guarantees as AWS’s best-in-class S3 storage.
<Note>
Pro and Enterprise customers can use their own S3 / S3-express buckets,
guaranteeing that data lives inside their infrastructure. In our future
roadmap, compute will also be runnable inside your account, for a full BYOC
solution
</Note>
## Short term and long term guarantees
Any SQLite-compatible database has mainly two storage components: The Write-Ahead Log, or WAL, which contains the most recent commits, and the database file. Periodically, the data in the WAL is folded back into the main database file.
New commits to the database that are sent to the Turso Cloud are stored in S3-express One Zone before they are acknowledged to the application. Periodically, the data is folded back into the main database file and stored on S3. As per AWS service agreement, both technologies provide a 99.999999999% durability guarantee.
## Commit latency
One of the reasons why an S3-based architecture is not as popular for transactional workloads as it is for analytical workloads is the high cost of writing to object store. Due to Turso Cloud’s multi-tenant architecture, commits are batched across many databases to amortize this cost.
Furthermore, commits are also batched in time, that is the added commit latency as described in Table 1.
The commit latency is not the expected latency in every commit, but the ceiling of added latency in each commit.
To understand how this works, let's consider the following scenario:
```mermaid
sequenceDiagram
participant Timeline
participant DB1 as Database 1
participant DB2 as Database 2
Note over Timeline: 0ms - Commit Window Starts
Timeline->>DB1: Commit c1 arrives
Note over DB1: Waits 10ms for batch
Note over Timeline: 4ms
Timeline->>DB2: Commit c1 arrives
Note over DB2: Waits 6ms for batch
Note over Timeline: 10ms - Commit Window Ends
Timeline->>DB1: Commit c2 arrives
Note over DB1: No wait (batch is ready)
Timeline-->>DB1: Acknowledge c1 and c2
Timeline-->>DB2: Acknowledge c1
```
Let's break it down:
* The first commit (c1) to database d1 that happens at the beginning of the 10ms commit window must wait the full 10ms
* The commit (c1) to database d2 that happens 4ms into the window only waits the remaining 6ms
* The second commit (c2) to database d1 that arrives exactly at the end of the commit window has no added latency
## Testing methodology
Turso Cloud server is written from the ground up to use Deterministic Simulation Testing. DST, for short, is a technique that automatically tests the code across a variety of possible, randomly generated inputs, and upon any failure generates a seed that deterministically reproduces the issue with all its preconditions.
In addition to our simulator, we rely on [Antithesis](https://antithesis.com) full-system Deterministic Simulation Hypervisor to test the interaction of the system with external components, like AWS S3 and S3-Express One Zone.
The combination of our ground-up DST server and Antithesis allows us to test years of possible combinations of unlikely scenarios over the course of mere hours, making sure the system works as specified.
# Data & Connections
Source: https://docs.turso.tech/data-and-connections
Learn how data consistency and connections work with Turso databases.
Turso, an extension of [libSQL](/libsql) (a SQLite fork), modifies the consistency model due to its network-accessible and replicated nature, deviating from SQLite's strictly serializable standard.
## Establishing Connections
Database operations begin with a client establishing either an HTTP or websocket connection to a database. Following this, an internal SQLite database connection is set up within the server to facilitate the operations.
## Data Consistency
Database operations are tightly controlled to maintain order and data integrity.
### Primary Database Operations
* All operations are linearizable, maintaining an ordered history.
* Writes are fully serialized, with subsequent writes awaiting transaction completion.
* Users should exercise caution with long-running or abandoned transactions to prevent blocking other writes.
## Transactional Consistency
* Transactions in libSQL, encompassing both batch and interactive transactions, adhere to SQLite's transaction semantics.
* libSQL provides snapshot isolation for read operations, ensuring immediate visibility of writes within the same process. This guarantees serializability and isolation from other transactions.
# AI & Embeddings
Source: https://docs.turso.tech/features/ai-and-embeddings
Vector Similarity Search is built into Turso and libSQL Server as a native feature.
Turso and libSQL enable vector search capability without an extension.
<Snippet file="technical-preview-banner.mdx" />
<Note>
Full support for vector search in the Turso platform starts from version `v0.24.24` <br />
(use the `turso group show <group-name>` command to check the group version).
</Note>
## How it works
* Create a table with one or more vector columns (e.g. `FLOAT32`)
* Provide vector values in binary format or convert text representation to binary using the appropriate conversion function (e.g. `vector32(...)`)
* Calculate vector similarity between vectors in the table or from the query itself using dedicated vector functions (e.g. `vector_distance_cos`)
* Create a special vector index to speed up nearest neighbors queries (use the `libsql_vector_idx(column)` expression in the `CREATE INDEX` statement to create vector index)
* Query the index with the special `vector_top_k(idx_name, q_vector, k)` [table-valued function](https://www.sqlite.org/vtab.html#table_valued_functions)
# Vectors
### Types
LibSQL uses the native SQLite BLOB [storage class](https://www.sqlite.org/datatype3.html#storage_classes_and_datatypes) for vector columns. To align with SQLite [affinity rules](https://www.sqlite.org/datatype3.html#determination_of_column_affinity), all type names have two alternatives: one that is easy to type and another with a `_BLOB` suffix that is consistent with affinity rules.
<Info>
We suggest library authors use type names with the `_BLOB` suffix to make
results more generic and universal. For regular applications, developers can
choose either alternative, as the type name only serves as a **hint** for
SQLite and external extensions.
</Info>
<Info>
As LibSQL does not introduce a new storage class, all metadata about vectors
is also encoded in the `BLOB` itself. This comes at the cost of a few bytes
per row but greatly simplifies the design of the feature.
</Info>
The table below lists six vector types currently supported by LibSQL. Types are listed from more precise and storage-heavy to more compact but less precise alternatives (the number of dimensions in vector $D$ is used to estimate storage requirements for a single vector).
| Type name                   | Storage (bytes)                 | Description                                                                                                                                                                                        |
| --------------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `FLOAT64` \| `F64_BLOB`     | $8D + 1$                        | Implementation of [IEEE 754 double precision format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) for 64-bit floating point numbers                                       |
| `FLOAT32` \| `F32_BLOB`     | $4D$                            | Implementation of [IEEE 754 single precision format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format) for 32-bit floating point numbers                                       |
| `FLOAT16` \| `F16_BLOB`     | $2D + 1$                        | Implementation of [IEEE 754-2008 half precision format](https://en.wikipedia.org/wiki/Half-precision_floating-point_format) for 16-bit floating point numbers                                      |
| `FLOATB16` \| `FB16_BLOB`   | $2D + 1$                        | Implementation of [bfloat16 format](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format) for 16-bit floating point numbers                                                                |
| `FLOAT8` \| `F8_BLOB`       | $D + 14$                        | LibSQL specific implementation which compresses each vector component to single `u8` byte `b` and reconstruct value from it using simple transformation: $\texttt{shift} + \texttt{alpha} \cdot b$ |
| `FLOAT1BIT` \| `F1BIT_BLOB` | $\lceil \frac{D}{8} \rceil + 3$ | LibSQL-specific implementation which compresses each vector component down to 1-bit and packs multiple components into a single machine word, achieving a very compact representation              |
<Info>
For most applications, the `FLOAT32` type should be a good starting point, but
you may want to explore more compact options if your table has a large number
of rows with vectors.
</Info>
<Info>
While `FLOAT16` and `FLOATB16` use the same amount of storage, they provide
different trade-offs between speed and accuracy. Generally, operations over
`bfloat16` are faster but come at the expense of lower precision.
</Info>
### Functions
To work with vectors, LibSQL provides several functions that operate in the vector domain. Each function understands vectors in binary format aligned with the six types described above or in text format as a single JSON array of numbers.
Currently, LibSQL supports the following functions:
| Function name                                                                      | Description                                                                                                                                                                  |
| ---------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `vector64` \| `vector32` \| `vector16` \| `vectorb16` \| `vector8` \| `vector1bit` | Conversion function which accepts a valid vector and converts it to the corresponding target type                                                                            |
| `vector`                                                                           | Alias for `vector32` conversion function                                                                                                                                     |
| `vector_extract`                                                                   | Extraction function which accepts valid vector and return its text representation                                                                                            |
| `vector_distance_cos`                                                              | Cosine distance (1 - [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity)) function which operates over vector of **same type** with **same dimensionality** |
| `vector_distance_l2`                                                               | Euclidean distance function which operates over vector of **same type** with **same dimensionality**                                                                         |
### Vectors usage
<Steps>
<Step title="Create a table">
Begin by declaring a column used for storing vectors with the `F32_BLOB` datatype:
```sql
CREATE TABLE movies (
title    TEXT,
year     INT,
full_emb F32_BLOB(4) -- 4-dimensional f32 vector
);
```
The number in parentheses `(4)` specifies the dimensionality of the vector. This means each vector in this column will have exactly 4 components.
</Step>
<Step title="Generate and insert embeddings">
Once you generate embeddings for your data (via an LLM), you can insert them into your table:
```sql
INSERT INTO movies (title, year, embedding)
VALUES
('Napoleon', 2023, vector32('[0.800, 0.579, 0.481, 0.229]')),
('Black Hawk Down', 2001, vector32('[0.406, 0.027, 0.378, 0.056]')),
('Gladiator', 2000, vector32('[0.698, 0.140, 0.073, 0.125]')),
('Blade Runner', 1982, vector32('[0.379, 0.637, 0.011, 0.647]'));
```
Popular tools like [LangChain](https://www.langchain.com), [Hugging Face](https://huggingface.co) or [OpenAI](https://turso.tech/blog/how-to-generate-and-store-openai-vector-embeddings-with-turso) can be used to generate embeddings.
</Step>
<Step title="Perform a vector similarity search">
You can now write queries combining vectors and standard SQLite data:
```sql
SELECT title,
vector_extract(embedding),
vector_distance_cos(embedding, vector32('[0.064, 0.777, 0.661, 0.687]'))
FROM movies
ORDER BY
vector_distance_cos(embedding, vector32('[0.064, 0.777, 0.661, 0.687]'))
ASC;
```
</Step>
</Steps>
### Understanding Distance Results
The `vector_distance_cos` function calculates the cosine distance, which is defined at:
* Cosine Distance = 1 — [Cosine Similarity](https://en.wikipedia.org/wiki/Cosine_similarity)
The cosine distance ranges from 0 to 2, where:
* A distance close to 0 indicates that the vectors are nearly identical or exactly matching.
* A distance close to 1 indicates that the vectors are orthogonal (perpendicular).
* A distance close to 2 indicates that the vectors are pointing in opposite directions.
<Note>
Very small negative numbers close to zero (for example, `-10^-14`) may
occasionally appear due to floating-point arithmetic precision. These should
be interpreted as effectively zero, indicating an exact or near-exact match
between vectors.
```sql
SELECT vector_distance_cos('[1000]', '[1000]');
-- Output: -2.0479999918166e-09
```
</Note>
### Vector Limitations
* Euclidean distance is **not supported** for 1-bit `FLOAT1BIT` vectors
* LibSQL can only operate on vectors with no more than 65536 dimensions
## Indexing
Nearest neighbors (NN) queries are popular for various AI-powered applications ([RAG](https://en.wikipedia.org/wiki/Retrieval-augmented_generation) uses NN queries to extract relevant information, and recommendation engines can suggest items based on embedding similarity).
LibSQL implements [DiskANN](https://turso.tech/blog/approximate-nearest-neighbor-search-with-diskann-in-libsql) algorithm in order to speed up approximate nearest neighbors queries for tables with vector columns.
<Note>
The DiskANN algorithm trades search accuracy for speed, so LibSQL queries may
return slightly suboptimal neighbors for tables with a large number of rows.
</Note>
### Vector Index
LibSQL introduces a custom index type that helps speed up nearest neighbors queries against a fixed distance function (cosine similarity by default).
From a syntax perspective, the vector index differs from ordinary application-defined B-Tree indices in that it must wrap the vector column into a `libsql_vector_idx` marker function like this
```sql
CREATE INDEX movies_idx ON movies (libsql_vector_idx(embedding));
```
<Note>
Vector index works only for column with one of the vector types described
above
</Note>
The vector index is fully integrated into the LibSQL core, so it inherits all operations and most features from ordinary indices:
* An index created for a table with existing data will be automatically populated with this data
* All updates to the base table will be **automatically** reflected in the index
* You can rebuild index from scratch using `REINDEX movies_idx` command
* You can drop index with `DROP INDEX movies_idx` command
* You can create [partial](https://www.sqlite.org/partialindex.html) vector index with a custom filtering rule:
```sql
CREATE INDEX movies_idx ON movies (libsql_vector_idx(embedding))
WHERE year >= 2000;
```
### Query
At the moment vector index must be queried **explicitly** with special `vector_top_k(idx_name, q_vector, k)` [table-valued function](https://www.sqlite.org/vtab.html#table_valued_functions). The function accepts index name, query vector and amount of neighbors to return. This function searches for `k` approximate nearest neighbors and returns `ROWID` of these rows or `PRIMARY KEY` if base index [do not have ROWID](https://www.sqlite.org/withoutrowid.html).
In order for table-valued function to work query vector **must** have the same vector type and dimensionality.
### Settings
LibSQL vector index optionally can accept settings which must be specified as a variadic parameters of the `libsql_vector_idx` function as a strings in the format `key=value`:
```sql
CREATE INDEX movies_idx
ON movies(libsql_vector_idx(embedding, 'metric=l2', 'compress_neighbors=float8'));
```
At the moment LibSQL supports the following settings:
| Setting key          | Value type                                                          | Description                                                                                                                                                                                                                                                                              |
| -------------------- | ------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `metric`             | `cosine` \| `l2`                                                    | Which distance function to use for building the index. <br /> Default: `cosine`                                                                                                                                                                                                          |
| `max_neighbors`      | positive integer                                                    | How many neighbors to store for every node in the DiskANN graph. The lower the setting -- the less storage index will use in exchange to search precision. <br /> Default: $3 \sqrt{D}$ where $D$ -- dimensionality of vector column                                                     |
| `compress_neighbors` | `float1bit`\|`float8`\|<br />`float16`\|`floatb16`\|<br />`float32` | Which vector type must be used to store neighbors for every node in the DiskANN graph. The more compact vector type is used for neighbors -- the less storage index will use in exchange to search precision. <br /> Default: **no compression** (neighbors has same type as base table) |
| `alpha`              | positive float $\geq 1$                                             | "Density" parameter of general sparse neighborhood graph build during DiskANN algorithm. The lower parameter -- the more sparse is DiskANN graph which can speed up query speed in exchange to lower search precision. <br />Default: `1.2`                                              |
| `search_l`           | positive integer                                                    | Setting which limits the amount of neighbors visited during vector search. The lower the setting -- the faster will be search query in exchange to search precision. <br />Default: `200`                                                                                                |
| `insert_l`           | positive integer                                                    | Setting which limits the amount of neighbors visited during vector insert. The lower the setting -- the faster will be insert query in exchange to DiskANN graph navigability properties. <br />Default: `70`                                                                            |
<Note>
Vector index for column of type `T1` with `max_neighbors=M` and
`compress_neighbors=T2` will approximately use $\texttt{N} (Storage(\texttt   {T1}) + \texttt{M} \cdot Storage(\texttt{T2}))$ storage bytes for `N` rows.
</Note>
### Index usage
<Steps>
<Step title="Create a table">
Begin by declaring a column used for storing vectors with the `F32_BLOB` datatype:
```sql
CREATE TABLE movies (
title    TEXT,
year     INT,
full_emb F32_BLOB(4), -- 4-dimensional f32 vector
);
```
The number in parentheses `(4)` specifies the dimensionality of the vector. This means each vector in this column will have exactly 4 components.
</Step>
<Step title="Generate and insert embeddings">
Once you generate embeddings for your data (via an LLM), you can insert them into your table:
```sql
INSERT INTO movies (title, year, embedding)
VALUES
('Napoleon', 2023, vector32('[0.800, 0.579, 0.481, 0.229]')),
('Black Hawk Down', 2001, vector32('[0.406, 0.027, 0.378, 0.056]')),
('Gladiator', 2000, vector32('[0.698, 0.140, 0.073, 0.125]')),
('Blade Runner', 1982, vector32('[0.379, 0.637, 0.011, 0.647]'));
```
Popular tools like [LangChain](https://www.langchain.com), [Hugging Face](https://huggingface.co) or [OpenAI](https://turso.tech/blog/how-to-generate-and-store-openai-vector-embeddings-with-turso) can be used to generate embeddings.
</Step>
<Step title="Create an Index">
Create an index using the `libsql_vector_idx` function:
```sql
CREATE INDEX movies_idx ON movies(libsql_vector_idx(embedding));
```
This creates an index optimized for vector similarity searches on the `embedding` column.
<Note>
The `libsql_vector_idx` marker function is **required** and used by libSQL to
distinguish `ANN`-indices from ordinary B-Tree indices.
</Note>
</Step>
<Step title="Query the indexed table">
```sql
SELECT title, year
FROM vector_top_k('movies_idx', vector32('[0.064, 0.777, 0.661, 0.687]'), 3)
JOIN movies ON movies.rowid = id
WHERE year >= 2020;
```
This query uses the `vector_top_k` [table-valued function](https://www.sqlite.org/vtab.html#table_valued_functions) to efficiently find the top 3 most similar vectors to `[0.064, 0.777, 0.661, 0.687]` using the index.
</Step>
</Steps>
### Index limitations
* Vector index works only for tables **with** `ROWID` or with singular `PRIMARY KEY`. Composite `PRIMARY KEY` without `ROWID` is not supported
# Attach Database (Deprecated)
Source: https://docs.turso.tech/features/attach-database
Attach and read data across multiple databases.
<Warning>
This feature is now deprecated for all new users. Existing paid users can
continue to use `ATTACH` — [read the
announcement](https://turso.tech/blog/upcoming-changes-to-the-turso-platform-and-roadmap)
</Warning>
The `ATTACH` statement enables you to link multiple databases within a single transaction, which is ideal for:
* Organizing data in a modular way
* Streamlining data access and enhancing scalability
* Aggregating data
## How it works
1. You enable the `ATTACH` feature on the databases you want to connect to.
2. You retrieve the **Database ID** for the database you want to `ATTACH`.
3. You connect to the database
* **CLI**: `--attach` flag to automatically create a token with the correct permissions.
* **SDK**: Create a token with the `attach` permission for the database you want to attach.
4. You invoke `ATTACH` to connect to the other databases within the database shell or SDK.
## Usage
You can use the `ATTACH` statement to connect to other databases within a transaction using the CLI, or libSQL SDK. Once attached, you can query the attached databases as if they were part of the current database using the assigned alias.
### Turso CLI
Make sure you have the [Turso CLI](/cli/installation) installed, and [logged in](/cli/auth/login).
<Steps>
<Step title="Enable attach on required databases">
You will first need to enable the `ATTACH` feature on the database(s) you want to attach:
```bash
turso db config attach allow <database-name>
```
</Step>
<Step title="Retrieve Database ID">
You now need to retrieve the **Database ID** for the database you want to `ATTACH`:
```bash
turso db show <database-name>
```
</Step>
<Step title="Connect to any database with attach">
Now pass the names of the databases via the `--attach` flag when connecting to your database(s):
```bash
turso db shell <database-name> --attach <...database-name(s)>
```
</Step>
<Step title="ATTACH">
Now once connected to the database you can invoke an `ATTACH` statement to connect the other database(s):
```sql
ATTACH "<database-id>" AS my_db;
```
</Step>
<Step title="Query">
Execute a query using the alias for any attached database(s):
```sql
SELECT * FROM my_db.my_table;
```
</Step>
</Steps>
### libSQL SDKs
You can use one of the libSQL client SDKs with [TypeScript](/sdk/ts), [Rust](/sdk/rust), [Go](/sdk/go), [Python](/sdk/python), or over [HTTP](/sdk/http).
<Steps>
<Step title="Enable attach on required databases">
You will first need to enable the `ATTACH` feature on the database(s) you want to attach:
```bash
turso db config attach allow <database-name>
```
</Step>
<Step title="Retrieve Database ID">
You now need to retrieve the **Database ID** for the database you want to `ATTACH`:
```bash
turso db show <database-name>
```
</Step>
<Step title="Create token with ATTACH permissions">
Now create a token for the libSQL client with the `attach` permission for the database you want to attach:
```bash
turso db tokens create <database-name> --attach <another-database-name>
```
</Step>
<Step title="Connect to any database with ATTACH">
Use a [Client SDK](/sdk) to attach the desired database within a read transaction:
<CodeGroup>
```ts @libsql/client
import { createClient } from "@libsql/client";
const client = createClient({
syncUrl: "libsql://...",
authToken: "...",
});
const txn = await db.transaction("read");
await txn.execute('ATTACH "<database-id>" AS my_db');
const rs = await txn.execute("SELECT * FROM my_db.my_table");
```
</CodeGroup>
</Step>
</Steps>
## Things to know
* You can only attach databases that have the `attach` feature enabled.
* You can only attach databases belonging to a group, and in the same group.
* There is a maximum of 10 databases that can be attached to a single transaction.
* The attached databases are read only.
* `ATTACH` statement can be used only within transactions.
* `ATTACH` doesn't support [Embedded Replicas](/features/embedded-replicas)
# Branching
Source: https://docs.turso.tech/features/branching
A branch is a separate database instance that is created from an existing database. You can also create a branch from a [point-in-time](/features/point-in-time-recovery) snapshot of a database. Branches are useful for development and testing, because they allow you to make changes to the database without affecting the original database.
## How it works
1. You create a new database from an existing database using the CLI or API.
2. You connect to the new database using the group API token.
3. Make changes to the new schema using a migration tool (optional).
4. Apply the changes to the original database using a migration tool when merging using a GitHub Action (optional).
5. Delete the database when you no longer need it.
## Usage
You can create a new database from an existing database using the CLI or API:
<CodeGroup>
```bash CLI
turso db create my-new-database-branch --from-db my-existing-database
```
```bash Platform API
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "new-database",
"group": "default",
"seed": {
"type:": "database",
"name": "my-existing-database"
}
}'
```
</CodeGroup>
Refer to the following references for more details about all arguments:
<CardGroup>
<Card horizontal title="CLI Reference" icon="terminal" href="/cli/db/create" />
<Card horizontal title="API Reference" icon="code" href="/api-reference/databases/create" />
</CardGroup>
## Things to know
* Database branches are completely separate from the original database. This means that you need to handle merging any schema changes or data manually using a migration tool.
* You will need to [create a new token](/cli/db/tokens/create) (or use a group token) to connect to the new database.
* You will need to manually delete the database branch when you no longer need it.
* Branches count towards your plan's database quota.
## CI/CD
Automating branching is useful for creating a new database for each pull request. This allows you to test changes without affecting the original database.
Here's an example of what that might look like using the [Platform API](/api-reference/databases/create):
```yml .github/workflows/create-database-branch.yml
name: Create Database
on: create
jobs:
triggerAPI:
runs-on: ubuntu-latest
steps:
- name: Generate Branch Name
id: branch_name
run: |
BRANCH_NAME=$(echo "${{ github.ref_name }}" | tr -cd '[:alnum:]' | sed 's/./\L&/g' | cut -c 1-32)
echo "::set-output name=branch_name::$BRANCH_NAME"
- name: Create Database
run: |
curl -X POST \
-H "Authorization: Bearer ${{ secrets.API_TOKEN }}" \
-H "Content-Type: application/json" \
-d '{"name": "${{ steps.branch_name.outputs.branch_name }}", "group": "default", "seed": {"type": "database", "name": "${{ secrets.DATABASE_NAME }}"} }' \
"https://api.turso.tech/v1/organizations/${{ secrets.ORGANIZATION_NAME }}/databases"
```
# Data Edge (Deprecated)
Source: https://docs.turso.tech/features/data-edge
Allow your users to reach local replicas of your database, wherever they are.
<Warning>
This feature is now deprecated for all new users. Existing users can continue
to use Edge Replicas on Fly — [read the
announcement](https://turso.tech/blog/upcoming-changes-to-the-turso-platform-and-roadmap)
</Warning>
In the realm of data management, each millisecond of latency is critical. That's why Turso offers over [30 locations](/cloud-providers#locations) for data storage and replication, ensuring minimal delay in data access.
For those seeking the ultimate in speed, Turso enables the [embedding of databases](/features/embedded-replicas) directly within your application on the same node. This configuration eliminates inter-regional request hopping, effectively bringing latency down to zero.
<iframe src="https://www.youtube.com/embed/DyO4OP5v0IM" title="YouTube video player" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen className="w-full aspect-video" />
## How it works
1. You create a database in a primary location
2. You add additional locations where data should be replicated
3. You query a single URL that automatically routes to the nearest edge
<Info>
Turso automatically handles keeping replicas updated — [learn more](/data-and-connections).
</Info>
## Add replica location
You can add locations to your database group using the [Turso CLI](/cli/group/locations/add) or [Platform API](/api-reference/groups/add-location):
<CodeGroup>
```bash CLI
turso group locations add <group-name> <location-code>
```
```bash Platform API
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/locations/{location}' \
-H 'Authorization: Bearer TOKEN'
```
</CodeGroup>
## Remove replica location
You can remove locations from your database group using the [Turso CLI](/cli/group/locations/remove) or [Platform API](/api-reference/groups/remove-location):
<CodeGroup>
```bash CLI
turso group locations remove <group-name> <...location-codes>
```
```bash Platform API
curl -L -X DELETE 'https://api.turso.tech/v1/organizations/{organizationSlug}/groups/{groupName}/locations/{location}' \
-H 'Authorization: Bearer TOKEN'
```
</CodeGroup>
# Embedded Replicas
Source: https://docs.turso.tech/features/embedded-replicas/introduction
Turso's embedded replicas are a game-changer for SQLite, making it more flexible and suitable for various environments. This feature shines especially for those using VMs or VPS, as it lets you replicate a Turso database right within your applications without needing to relying on Turso's [edge network](/features/data-edge). For mobile applications, where stable connectivity is a challenge, embedded replicas are invaluable as they allow uninterrupted access to the local database.
Embedded replicas provide a smooth switch between local and remote database operations, allowing the same database to adapt to various scenarios effortlessly. They also ensure speedy data access by syncing local copies with the remote database, enabling microsecond-level read operations — a significant advantage for scenarios demanding quick data retrieval.
<Warning>Support for Embedded Replicas on AWS is coming soon</Warning>
## How it works
1. You configure a local file to be your main database.
* The `url` parameter in the client configuration.
2. You configure a remote database to sync with.
* The `syncUrl` parameter in the client configuration.
3. You read from a database:
* Reads are always served from the local replica configured at `url`.
4. You write to a database:
* Writes are always sent to the remote primary database configured at `syncUrl`.
* Any write transactions with reads are also sent to the remote primary database.
* Once the write is successful, the local database is updated with the changes automatically (read your own writes — can be disabled).
### Periodic sync
You can automatically sync data to your embedded replica using the periodic sync interval property. Simply pass the `syncInterval` parameter when instantiating the client:
```ts
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:path/to/db-file.db",
authToken: "...",
syncUrl: "...",
syncInterval: 60,
});
```
### Read your writes
Embedded Replicas also will guarantee read-your-writes semantics. What that means in practice is that after a write returns successfully, the replica that initiated the write will always be able to see the new data right away, even if it never calls `sync()`.
Other replicas will see the new data when they call `sync()`, or at the next sync period, if [Periodic Sync](#periodic-sync) is used.
![Read your writes](https://mintlify.s3.us-west-1.amazonaws.com/turso/features/embedded-replicas/read-your-writes.png)
### Encryption at rest
Embedded Replicas support encryption at rest with one of the libSQL client SDKs. Simply pass the `encryptionKey` parameter when instantiating the client:
<CodeGroup>
<Snippet file="encryption-at-rest-typescript.mdx" />
<Snippet file="encryption-at-rest-golang.mdx" />
<Snippet file="encryption-at-rest-rust.mdx" />
<Snippet file="encryption-at-rest-python.mdx" />
<Snippet file="encryption-at-rest-flutter.mdx" />
</CodeGroup>
<Note>The encryption key used should be generated and managed by you.</Note>
## Usage
To use embedded replicas, you need to create a client with a `syncUrl` parameter. This parameter specifies the URL of the remote Turso database that the client will sync with:
<CodeGroup>
```ts TypeScript
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:replica.db",
syncUrl: "libsql://...",
authToken: "...",
});
```
```go Go
package main
import (
"database/sql"
"fmt"
"os"
"path/filepath"
"github.com/tursodatabase/go-libsql"
)
func main() {
dbName := "local.db"
primaryUrl := "libsql://[DATABASE].turso.io"
authToken := "..."
dir, err := os.MkdirTemp("", "libsql-*")
if err != nil {
fmt.Println("Error creating temporary directory:", err)
os.Exit(1)
}
defer os.RemoveAll(dir)
dbPath := filepath.Join(dir, dbName)
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
)
if err != nil {
fmt.Println("Error creating connector:", err)
os.Exit(1)
}
defer connector.Close()
db := sql.OpenDB(connector)
defer db.Close()
}
```
```rust Rust
use libsql::{Builder};
let build = Builder::new_remote_replica("file:replica.db", "libsql://...", "...")
.build()
.await?;
let client = build.connect()?;
```
```php PHP
use Libsql\Database;
$db = new Database(
path: 'replica.db',
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
syncInterval: 300 // Sync every 5 minutes
);
$conn = $db->connect();
```
```php Laravel
// config/database.php
return [
"default" => env("DB_CONNECTION", "libsql"),
"connections" => [
"libsql" => [
"driver" => "libsql",
"database" => database_path("database.db"),
"url" => env("TURSO_DATABASE_URL"),
"password" => env("TURSO_AUTH_TOKEN"),
"sync_interval" => env("TURSO_SYNC_INTERVAL", 300),
],
// ...
],
];
// .env
DB_CONNECTION=libsql
TURSO_DATABASE_URL=libsql://...
TURSO_AUTH_TOKEN=...
TURSO_SYNC_INTERVAL=300
```
</CodeGroup>
You can sync changes from the remote database to the local replica manually:
<CodeGroup>
```ts TypeScript
await client.sync();
```
```go Go
if err := connector.Sync(); err != nil {
fmt.Println("Error syncing database:", err)
}
```
```rust Rust
client.sync().await?;
```
```php PHP
$db->sync();
```
</CodeGroup>
<br />
<Note>
You should call `.sync()` in the background whenever your application wants to sync the remote and local embedded replica. For example, you can call it every 5 minutes or every time the application starts.
</Note>
## Things to know
* Do not open the local database while the embedded replica is syncing. This can lead to data corruption.
* In certain contexts, such as serverless environments without a filesystem, you can't use embedded replicas.
* There are a couple scenarios where you may sync more frames than you might
expect.
* A write that causes the internal btree to split at any node would cause many
new frames to be written to the replication log.
* A server restart that left the on-disk wal in dirty state would regenerate
the replication log and sync additional frames.
* Removing/invalidating the local files on disk could cause the embedded
replica to re-sync from scratch.
* One frame equals 4kB of data (one on disk page frame), so if you write a 1
byte row, it will always show up as a 4kB write since that is the unit in
which libsql writes with.
## Deployment Guides
<CardGroup cols={2}>
<Card href="/features/embedded-replicas/with-fly" title="Turso + Fly">
Deploy a JavaScript project with Embedded Replicas to Fly.io
</Card>
<Card href="/features/embedded-replicas/with-koyeb" title="Turso + Koyeb">
Deploy a JavaScript/Rust project with Embedded Replicas to Koyeb
</Card>
<Card href="/features/embedded-replicas/with-railway" title="Turso + Railway">
Deploy a JavaScript/Rust project with Embedded Replicas to Railway
</Card>
<Card href="/features/embedded-replicas/with-render" title="Turso + Render">
Deploy a JavaScript project with Embedded Replicas to Render
</Card>
<Card href="/features/embedded-replicas/with-akamai" title="Turso + Linode by Akamai">
Deploy a JavaScript/Rust project with Embedded Replicas to Akamai
</Card>
</CardGroup>
# Turso + Linode by Akamai
Source: https://docs.turso.tech/features/embedded-replicas/with-akamai
Deploy a JavaScript/Rust app using [Turso embedded replicas](/features/embedded-replicas) to [Akamai](https://www.linode.com/).
![Akamai banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/akamai-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an Akamai account - [create one](https://login.linode.com/signup)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step>
Fork one of the following embedded replica projects from GitHub
<CardGroup cols={2}>
<Card title="My Expenses Tracker - (Elysia + Bun)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-js">
See the full source code
</Card>
<Card title="Web Traffic API - (Rust)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-rust">
See the full source code
</Card>
</CardGroup>
</Step>
<Step title="Set up a Linode server">
Configure and create a new linode. Then, [set up SSH authentication](https://www.linode.com/docs/guides/use-public-key-authentication-with-ssh/) to securely access the Linode server from your terminal.
Prepare the newly created linode server environment by accessing and set it up for Rust/JavaScript development depending on the project you forked earlier. Install and set up [Git](https://git-scm.com/) too.
</Step>
<Step title="Transfer project to Linode server">
SSH into your server, clone the project from GitHub, and follow its README instructions to set it up.
</Step>
<Step title="Deploy">
Build, run the project, and set up load balancing for it.
[pm2](https://www.npmjs.com/package/pm2) is one of the good candidates out there with built-in load balancing, log monitoring, and bug/exception alerts.
<Info>
You can go with your favorite options for where to buy domains, reverse proxy setup, and SSL certificates. [Caddy](https://caddyserver.com/) is another good option here.
</Info>
</Step>
</Steps>
# Embedded Replicas on Fly
Source: https://docs.turso.tech/features/embedded-replicas/with-fly
Deploy a JavaScript app using [Turso embedded replicas](/features/embedded-replicas) to [Fly.io](https://www.fly.io/).
![Koyeb banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/fly-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* [Install the Fly.io CLI](https://fly.io/docs/hands-on/install-flyctl/)
<Steps>
<Step title="Locate your application">
You should have an application ready using your Turso database that you want to deploy to Fly.
</Step>
<Step title="Launch with Fly">
Using the Fly CLI, launch it:
```bash
fly launch
```
Your application will automatically deploy to Fly, but we're not ready yet.
</Step>
<Step title="Create a shared volume">
Now create a volume that will be used to store the embedded replica(s):
```bash
fly volumes create libsql_data
```
</Step>
<Step title="Mount and configure volumes">
The files `fly.toml` and `Dockerfile` created created when you launched previously.
Update `fly.toml` this file to mount the new volume:
```toml
[[mounts]]
source = "libsql_data"
destination = "/app/data"
```
Then inside `Dockerfile`, make sure you install and update `ca-certificates`:
```dockerfile
RUN apt-get update -qq && \
apt-get install -y ca-certificates && \
update-ca-certificates
```
Make sure to also add the following line after any `COPY` commands to copy the certificates:
```dockerfile
COPY --from=build /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
```
</Step>
<Step title="Configure the libSQL client">
You will want to change the `url` to point to a local file, and set the `syncUrl` to be your Turso database URL:
```ts
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:./app/data/local.db",
syncUrl: process.env.TURSO_DATABASE_URL,
authToken: process.env.TURSO_AUTH_TOKEN,
syncInterval: 60,
});
```
</Step>
<Step title="Deploy your updated app">
```bash
fly deploy
```
</Step>
</Steps>
# Turso + Koyeb
Source: https://docs.turso.tech/features/embedded-replicas/with-koyeb
Deploy a JavaScript/Rust app using [Turso embedded replicas](/features/embedded-replicas) to [Koyeb](https://www.koyeb.com/).
![Koyeb banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/koyeb-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Koyeb account - [create one](https://app.koyeb.com/)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step>
Fork one of the following embedded replica project from GitHub
<CardGroup cols={2}>
<Card title="My Expenses Tracker - (Elysia + Bun)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-js">
See the full source code
</Card>
<Card title="Web Traffic API - (Rust)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-rust">
See the full source code
</Card>
</CardGroup>
<Note>
Or, you can:
<Card title="Deploy to Koyeb with a single-click" href="https://app.koyeb.com/deploy?name=er-with-js&type=git&repository=tursodatabase/embedded-replicas-with-js&branch=main&env[PORT]=8000&env[TURSO_DATABASE_URL]=REPLACE_ME&env[TURSO_AUTH_TOKEN]=REPLACE_ME&env[LOCAL_DB]=file:expenses.db" />
</Note>
</Step>
<Step title="Add a new Koyeb app">
1. Create a new app in the Koyeb control panel.
2. Select GitHub as the deployment option.
3. Import the GitHub project to Koyeb.
</Step>
<Step title="Fill in the environment variables on Koyeb's deploy page">
![Koyeb deploy page - environment variables](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/koyeb-env-variables.png)
</Step>
<Step title="Deploy">
Click the **Deploy** button at the bottom to deploy your web service.
</Step>
</Steps>
# Turso + Railway
Source: https://docs.turso.tech/features/embedded-replicas/with-railway
Deploy a JavaScript/Rust app using [Turso embedded replicas](/features/embedded-replicas) to [Railway](https://railway.app/).
![Koyeb banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/railway-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* [Install the Railway CLI](https://docs.railway.app/guides/cli#installing-the-cli)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Get application code">
Fork and clone the following embedded replica project from GitHub locally:
<CardGroup cols={2}>
<Card title="My Expenses Tracker - (Elysia + Bun)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-js">
See the full source code
</Card>
<Card title="Web Traffic API - (Rust)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-rust">
See the full source code
</Card>
</CardGroup>
</Step>
<Step title="Create a new Railway project">
Run the following command to create a new Railway project. Provide the project's name when prompted.
```sh
railway init
```
</Step>
<Step title="Add a service to the Railway project">
[Create a new empty service](https://docs.railway.app/guides/services#creating-a-service) on your Railway project to act as your app's deployment target.
</Step>
<Step title="Link application to service">
Run the following command to list and select the service to link to your application:
```sh
railway service
```
</Step>
<Step title="Add database credentials">
Open the service on your Railway dashboard and add your Turso database Credentials.
```sh
TURSO_DATABASE_URL=libsql://[db-name]-[github-username].turso.io
TURSO_AUTH_TOKEN=...
LOCAL_DB=file:local-db-name.db
```
</Step>
<Step title="Deploy">
Run the following command to deploy your application:
```sh
railway up
```
<Info>
Make sure you [expose your application to the internet](https://docs.railway.app/guides/public-networking) to make it accessible from the public network.
</Info>
<Warning>
If you are on a free plan, you'll need to connect your Railway account to GitHub to have access to code deployments.
</Warning>
</Step>
</Steps>
# Turso + Render
Source: https://docs.turso.tech/features/embedded-replicas/with-render
Deploy a JavaScript app using [Turso embedded replicas](/features/embedded-replicas) to [Render](https://render.com/).
![Render banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/platforms/render-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Render account - [create one](https://dashboard.render.com/)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Get application code">
Fork the following embedded replica project from GitHub locally:
<Card title="My Expenses Tracker - (Elysia + Bun)" icon="github" href="https://github.com/tursodatabase/embedded-replicas-with-js">
See the full source code
</Card>
<Note>
Or, you can:
<Card title="Deploy to Render with a single-click" href="https://render.com/deploy?repo=https://github.com/tursodatabase/embedded-replicas-with-js" />
</Note>
</Step>
<Step title="Create a web service">
Create a new Render **Web Service** by clicking on the "New Web Service" button on the Web Services card inside you Render dashboard.
</Step>
<Step title="Connect to Git repository">
1. Select "build and deploy from a Git repository" and proceed to the next page.
2. Click on "Connect" for your target project repository
</Step>
<Step title="Set project's environment variables">
On the web service configuration page, under "Advanced" add **a secret file** and fill it in with your database secret credentials:
![Render secret credentials](https://mintlify.s3.us-west-1.amazonaws.com/turso/features/embedded-replicas/images/platforms/render-env-vars.png)
</Step>
<Step title="Deploy project">
Scroll to the bottom of the web service configuration page and click on "Create Web Service".
</Step>
</Steps>
# Multi-DB Schemas (Deprecated)
Source: https://docs.turso.tech/features/multi-db-schemas
Create and share a single schema across multiple databases.
<Warning>
This feature is now deprecated for all new users. Existing paid users can
continue to use Multi-DB Schemas — [read the
announcement](https://turso.tech/blog/upcoming-changes-to-the-turso-platform-and-roadmap)
</Warning>
Turso allows you to create a single schema and share it across multiple databases. This is useful for creating a multi-tenant application where each tenant has their own database.
<Info>
Try the [Turso Per User Starter](https://github.com/notrab/turso-per-user-starter) to get started with a multi-tenant application using Next.js, Drizzle, Clerk, libSQL, and Turso Multi-DB Schemas.
</Info>
## How it works
1. You create a database that is used as the parent schema database.
2. You create one or more databases that are used as the child databases.
3. You apply schema changes to the parent database, child databases are automatically updated with the new schema.
## Usage
You can create and manage parent or child databases using the [Turso CLI](/cli/db/create), and [Platform API](/api-reference/databases/create).
<iframe src="https://www.youtube.com/embed/Slacu1aGm8A" title="Multi database schema changes" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen className="w-full aspect-video" />
### Turso CLI
Make sure you have the [Turso CLI](/cli/installation) installed, and [logged in](/cli/auth/login).
<Steps>
<Step title="Create Parent Database">
Create a single database using the `--type` flag set to `schema`:
```bash
turso db create parent-db --type schema
```
</Step>
<Step title="Create Schema">
Connect to your database using the shell to `CREATE TABLE`, `CREATE TRIGGER`, `CREATE VIEW`, and anything else to setup your schema:
```bash
turso db shell parent-db
```
</Step>
<Step title="Create Child Database(s)">
Create one or more child databases using the `--schema` flag with the name of the parent database:
```bash
turso db create child-db --schema parent-db
```
</Step>
<Step title="Apply Additional Schema Changes">
You can now apply additional schema changes to the parent database, and the child databases will be automatically updated:
```bash
turso db shell parent-db "CREATE TABLE users (id INT PRIMARY KEY, name TEXT);"
```
</Step>
</Steps>
### Platform API
Make sure you have an API Token, and know your Organization name:
<Steps>
<Step title="Create Parent Database">
Create a database and set the `is_schema` field to `true`:
```bash
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "parent-db",
"group": "default",
"is_schema": true
}'
```
</Step>
<Step title="Create Schema">
Connect to your database using the shell, [SDK](/sdk), or migration script to `CREATE TABLE`, `CREATE TRIGGER`, `CREATE VIEW`, and anything else to setup your schema:
```bash Turso CLI
turso db shell parent-db
```
</Step>
<Step title="Create Child Database(s)">
Create one or more child databases and pass the `schema` field the name of your parent database:
```bash
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "child-db",
"group": "default",
"schema": "parent-db"
}'
```
</Step>
<Step title="Apply Additional Schema Changes">
You can now apply additional schema changes to the parent database, and the child databases will be automatically updated:
```bash
turso db shell parent-db "CREATE TABLE users (id INT PRIMARY KEY, name TEXT);"
```
</Step>
</Steps>
## Things to know
* Schema databases cannot be shared across groups or globally via an organization/account.
* You can (but not recommended) `INSERT` rows into the parent database that can be queried by the child database(s).
* Be aware of any constraints that may conflict with the child database(s).
* You can't delete a parent database if it has one or more child databases.
* When a migration is applied to the schema database:
* It's first run as a dry-run on the schema and all other associated databases.
* If successful, a migration job is created.
* Tasks are created for each database that references this schema.
* The migration is then applied to each referencing database.
* Finally, if all tasks succeed, the migration is applied to the schema database itself.
* You can't create or delete a database if there are any migrations running.
* **During a migration, all databases are locked to write operations.**
* Make sure any application querying the child databases handle any databases not yet updated with the schema.
* You cannot apply schema changes to a child database directly. You must use the parent (schema) database.
* You can check the status of a migration using the `/jobs` endpoint — [learn more](/sdk/http/reference#schema-migration-jobs).
# Platform API
Source: https://docs.turso.tech/features/platform-api
Manage databases, and teams with the Turso Platform API.
The Turso [Platform API](/api-reference) is a RESTful API that allows you to manage databases, and users. It is the same API that is used by the Turso Platform Web UI and [CLI](/cli).
The API is built for platforms that want to integrate with Turso to provide their users a serverless SQLite database.
You can create databases, [database branches](/features/branching), [recover databases](/features/point-in-time-recovery) from a point in time, as well as [manage teams](/features/organizations), API tokens, and more with the Turso Platform API.
## API Resources
<Snippet file="platform-api-links.mdx" />
# Point-in-Time Recovery
Source: https://docs.turso.tech/features/point-in-time-recovery
Turso supports point-in-time recovery (PITR) for databases. PITR allows you to restore a database to a specific point in time. This is useful for recovering from user errors, such as dropping a table by mistake.
<Info>
Backups are created automatically at `COMMIT`. Free plan users can restore to any point in time within the last 24 hours. Hobby, Scaler, and Pro users can restore to any point in time within the last 10, 30, or 90 days, respectively.
</Info>
## How it works
1. You create a new database from the existing database using the CLI or API.
2. You update your application to use the new database connection string.
3. You delete the old database when you no longer need it.
<Info>
The newly created database includes data only from periods prior to the specified timestamp. Additionally, there may be a gap of up to 15 seconds in the data immediately preceding the timestamp, as this depends on the timing of Turso's most recent periodic batch checkpoint.
</Info>
## Usage
<CodeGroup>
```bash CLI
turso db create my-new-database --from-db my-existing-database --timestamp 2024-01-01T00:00:00Z
```
```bash Platform API
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "new-database",
"group": "default",
"seed": {
"type:": "database",
"name": "my-existing-database",
"timestamp": "2024-01-01T00:00:00Z"
}
}'
```
</CodeGroup>
Refer to the following references for more details about all arguments:
<CardGroup>
<Card horizontal title="CLI Reference" icon="terminal" href="/cli/db/create" />
<Card horizontal title="API Reference" icon="code" href="/api-reference/databases/create" />
</CardGroup>
## Things to know
* Restoring from a PITR creates a new database. You will need to update your application to use the new database connection string.
* You cannot restore from a PITR to a database that already exists.
* You will need to [create a new token](/cli/db/tokens/create) (or use a group token) to connect to the new database.
* You will need to manually delete the old database when you no longer need it.
* Restores count towards your plan's database quota.
# Scale to Zero
Source: https://docs.turso.tech/features/scale-to-zero
<Warning>
This feature is now deprecated for all new users. Existing free users will be
moved from Fly to AWS, and receive no cold starts by default — [read the
announcement](https://turso.tech/blog/upcoming-changes-to-the-turso-platform-and-roadmap)
</Warning>
For free Starter Plan users, Turso dynamically scales databases down to zero after an hour of no activity. This behaviour is how we can continue to provide hundreds of databases on the free plan.
When a request is made, the databases automatically scale back up to one. There may be a delay of up to `500ms` for databases that have been inactive.
<Info>
[Database groups](/concepts#groups) with extended inactivity (**10 days**) will require a manual "unarchive" operation using the [CLI](/cli/group/unarchive) or API.
</Info>
# Usage & Billing
Source: https://docs.turso.tech/help/usage-and-billing
For the Starter and Scaler plans, Turso usage is limited monthly based on the following usage observations during each calendar month:
* Number of table [rows read](#rows-read)
* Number of table [rows written](#rows-written)
* Amount of [total storage](#total-storage)
<Info>
In billing plans that include monthly quotas for row reads, row writes, and total storage, any query that exceeds these limits will result in a failure, indicated by the `BLOCKED` error code.
</Info>
## Rows Read
In SQLite, the term "row read" actually refers to a "row scan" during statement execution. Key points to remember with the Turso CLI metrics:
* **SQL Queries:** May scan more rows than returned.
* **SQL Updates:** Each updated row results in at least one row scan.
### Aggregate Function Impact
Using functions like `count`, `avg`, `min`, `max`, and `sum` results in a row scan for every row considered in the aggregation.
<Info>
Improve query efficiency by storing aggregate values in a separate table and
updating it transactionally with the base table changes.
</Info>
### Full Table Scans
Queries lacking index support perform a full table scan, incurring a row scan for each table row.
<Info>
Seek strategies to minimize costly table scans.
</Info>
### Complex Query Costs
Table joins, subqueries, and compound queries incur a row scan for each considered row from all involved tables.
### Update Mechanics
SQL updates read (and write) each row they modify. Absent an index for row filtering, a full table scan is performed, adding a read for each table row, plus a write for each updated row.
### `ALTER TABLE` and Row Reads
`ALTER TABLE` operations, especially those rewriting row contents, necessitate a full table scan, incurring a read for each table row. However, not all `ALTER TABLE` actions, like `DROP COLUMN`, lead to full scans. Be mindful of potential row writes as well.
### Indexing Costs
Adding an index to an existing table triggers a full table scan, with one read per existing row.
### SQLite System Tables
Internal SQLite tables, like `dbstat` and those with `sqlite_` prefix, don't incur row reads in queries.
### Zero-Read Commands
Commands not involving row reads/writes, like `select 1`, default to one row read.
## Rows Written
In SQLite, a "row written" encompasses both the insertion of a new row and the update of an existing row.
### `ALTER TABLE` and Row Writes
`ALTER TABLE` operations can result in a row write for each existing row, especially if the row data is altered during the process. It's important to understand how different types of `ALTER TABLE` statements impact row writes.
### Implications of Aborted Transactions
Even if a transaction is not committed, any row that was inserted or updated during the transaction incurs a row write. This underscores the importance of transaction management in controlling database writes.
<Note>
`ALTER TABLE` actions may also lead to row reads, adding another layer to consider when modifying table structures.
</Note>
## Total Storage
SQLite utilizes the virtual table [`dbstat`](https://www.sqlite.org/dbstat.html) to calculate the total space used by all tables and indexes. The base unit for this measurement is a database file page, which is 4KB.
<Note>
In SQLite, the `VACUUM` command is a common tool for optimizing storage by compacting the database. However, it's important to note that this command is currently disabled in Turso. Future updates may introduce options for developers to efficiently manage and reduce the total storage footprint of their databases.
</Note>
## Reducing Usage
### Query Execution
Familiarizing yourself with the [SQLite query planner](https://www.sqlite.org/queryplanner.html) can significantly enhance your understanding of how your queries are executed. This knowledge is pivotal in optimizing query efficiency.
### Query Planning
Utilize the [`EXPLAIN QUERY PLAN`](https://www.sqlite.org/eqp.html) statement to gain insights into your query's execution plan. This tool is invaluable for identifying whether your query is performing a full table scan and if it's leveraging the most efficient index to reduce unnecessary reads.
### Indexing
Ensure that your queries are designed to take advantage of indexes for row filtering. The absence of suitable indexes forces SQLite to resort to full table scans, incrementally increasing the read count by one for each row in the table. Efficient indexing is key to minimizing this overhead.
Incorporating necessary indexes at the table creation stage is a best practice. Adding indexes to tables that already contain rows triggers a full table scan, with each existing row necessitating one read. Proactive index management is crucial for maintaining optimal database performance.
# Welcome to Turso Cloud
Source: https://docs.turso.tech/introduction
SQLite for Production. Powered by libSQL.
<Frame>
![Turso Quickstart](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/turso-banner.png)
</Frame>
## New to Turso?
Turso is a SQLite-compatible database built on [libSQL](/libsql), the Open Contribution fork of SQLite.
<CardGroup cols={2}>
<Card
title="Get Started"
icon={
<svg
width="25"
viewBox="0 0 48 43"
fill="none"
xmlns="http://www.w3.org/2000/svg"
>
<g clip-path="url(#clip0_172_7499)">
<path
d="M32.32 20.36L32.82 27.08L33.01 29.59L30.57 30.21C29.06 30.59 26.99 31.12 24 31.12C21.01 31.12 18.94 30.59 17.43 30.21L14.99 29.59L15.18 27.08L15.68 20.36L7.79999 17.62C8.26999 22.97 10.11 33.84 10.66 34.9C11.3 36.12 14.69 39.62 17.34 40.96C17.34 40.96 18.3 39.94 18.89 39.04C19.63 39.92 23.48 43.01 24 43.01C24.52 43.01 28.37 39.92 29.11 39.04C29.7 39.94 30.66 40.96 30.66 40.96C33.31 39.62 36.7 36.12 37.34 34.9C37.89 33.84 39.73 22.97 40.2 17.62L32.32 20.36Z"
fill="#1EBCA1"
/>
<path
d="M29.15 18.28L48 11.73C46.88 4.99 41 0.01 41 0.01V7.42L37.51 8.32L35.32 5.67L33.45 9.37L24 11.82L14.55 9.37L12.68 5.67L10.49 8.32L7 7.42V0C7 0 1.12 4.99 0 11.72L18.85 18.27L18.18 27.29C19.79 27.7 21.48 28.11 24.01 28.11C26.54 28.11 28.23 27.7 29.84 27.29L29.17 18.27L29.15 18.28Z"
fill="#1EBCA1"
/>
</g>
<defs>
<clipPath id="clip0_172_7499">
<rect width="48" height="43" fill="white" />
</clipPath>
</defs>
</svg>
}
href="/quickstart"
>
Create your first database
</Card>
<Card
title="Embedded Replicas"
icon={
<svg viewBox="0 0 216 216" xmlns="http://www.w3.org/2000/svg">
<path
d="m25.3 114.3 15.9 48c1.5 4.5 5 8 9.5 9.5l48 15.9c5.3 1.8 11.2.4 15.2-3.6l76.7-76.7c3-3 4.6-7.1 4.3-11.4l-3.7-64c-.3-5.5-4.7-10-10.3-10.3l-64-3.7c-4.2-.2-8.4 1.3-11.4 4.3l-76.6 76.8c-4 4-5.4 9.9-3.6 15.2z"
fill="none"
stroke="#1ebca1"
stroke-miterlimit="10"
stroke-width="19.2"
/>
<path
d="m119.2 82.2 6.5-1.5c2.9-.7 5.8 1.2 6.5 4.1.2.8.2 1.6 0 2.4l-1.5 6.5c-3.3 12.4-21.1 8.4-18.8-4.2.8-3.8 3.8-6.5 7.3-7.3z"
fill="#1ebca1"
/>
<path
d="m21.1 191.8 99.8-99.8"
fill="none"
stroke="#1ebca1"
stroke-linecap="round"
stroke-linejoin="round"
stroke-width="19.2"
/>
<g fill="#1ebca1">
<path d="m141.8 142.4c-1.4 1.4-3.5 1.9-5.4 1.3l-13.3-4.4c-2-.7-4.3-.1-5.8 1.4l-8.9 8.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
<path d="m107 177.2c-1.4 1.4-3.5 1.9-5.4 1.3l-14.6-4.8c-1.2-.4-2.5 0-3.4.8l-9.9 9.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
<path d="m175.2 109c-1.4 1.4-3.5 1.9-5.4 1.3l-13.3-4.4c-2-.7-4.3-.1-5.8 1.4l-8.9 8.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
</g>
</svg>
}
href="/features/embedded-replicas/introduction"
>
Get zero latency reads on-device
</Card>
<Card
title="AI & Embeddings"
icon={
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="#1ebca1">
<path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" />
</svg>
}
href="/features/ai-and-embeddings"
>
Vector is just another datatype
</Card>
<Card
icon={
<svg
xmlns="http://www.w3.org/2000/svg"
fill="none"
viewBox="0 0 24 24"
stroke-width="1.5"
stroke="#1ebca1"
>
<path
stroke-linecap="round"
stroke-linejoin="round"
d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3"
/>
</svg>
}
title="Backups and Recovery"
href="/features/point-in-time-recovery"
>
Restore your database to any point in time
</Card>
</CardGroup>
## Start building
Learn how to manage, distribute and integrate your databases with the CLI, API and SDKs.
<CardGroup cols={2}>
<Card title="Turso CLI" icon="terminal" href="/cli">
Manage groups, databases, and API tokens with the Turso CLI.
</Card>
<Card title="Turso Platform API" icon="database" href="/api-reference">
Manage groups, databases, and API tokens with the Turso API.
</Card>
<Card
title="Client SDKs"
icon={
<svg viewBox="0 0 216 216" xmlns="http://www.w3.org/2000/svg">
<path
d="m25.3 114.3 15.9 48c1.5 4.5 5 8 9.5 9.5l48 15.9c5.3 1.8 11.2.4 15.2-3.6l76.7-76.7c3-3 4.6-7.1 4.3-11.4l-3.7-64c-.3-5.5-4.7-10-10.3-10.3l-64-3.7c-4.2-.2-8.4 1.3-11.4 4.3l-76.6 76.8c-4 4-5.4 9.9-3.6 15.2z"
fill="none"
stroke="#1ebca1"
stroke-miterlimit="10"
stroke-width="19.2"
/>
<path
d="m119.2 82.2 6.5-1.5c2.9-.7 5.8 1.2 6.5 4.1.2.8.2 1.6 0 2.4l-1.5 6.5c-3.3 12.4-21.1 8.4-18.8-4.2.8-3.8 3.8-6.5 7.3-7.3z"
fill="#1ebca1"
/>
<path
d="m21.1 191.8 99.8-99.8"
fill="none"
stroke="#1ebca1"
stroke-linecap="round"
stroke-linejoin="round"
stroke-width="19.2"
/>
<g fill="#1ebca1">
<path d="m141.8 142.4c-1.4 1.4-3.5 1.9-5.4 1.3l-13.3-4.4c-2-.7-4.3-.1-5.8 1.4l-8.9 8.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
<path d="m107 177.2c-1.4 1.4-3.5 1.9-5.4 1.3l-14.6-4.8c-1.2-.4-2.5 0-3.4.8l-9.9 9.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
<path d="m175.2 109c-1.4 1.4-3.5 1.9-5.4 1.3l-13.3-4.4c-2-.7-4.3-.1-5.8 1.4l-8.9 8.9c-1.8 1.8-1.1 4.8 1.3 5.6l20.6 6.8c8.9 2.9 18.4.6 25-5.9" />
</g>
</svg>
}
href="/sdk"
>
Connect and integrate Turso into your application with one of our libSQL
drivers.
</Card>
<Card title="Tutorials" icon="newspaper" href="https://turso.tech/blog">
Learn how to work with Turso and your favorite language or framework.
</Card>
</CardGroup>
## Join the community
Join the Turso community to ask questions, discuss best practices, and share tips.
<CardGroup cols={3}>
<Card title="Discord" icon="discord" href="https://discord.gg/turso" />
<Card title="GitHub" icon="star" href="https://github.com/tursodatabase" />
<Card title="X (Twitter)" icon="x-twitter" href="https://twitter.com/tursodatabase" />
</CardGroup>
# libSQL
Source: https://docs.turso.tech/libsql
libSQL is SQLite for modern applications.
Turso is a distributed database built on [libSQL](https://github.com/tursodatabase/libsql/), a fork of SQLite. It's optimized for low query latency, making it suitable for global applications.
Postgres and MySQL have long vied for SQL dominance, while SQLite remains a favored choice due to its simplicity and reliability, often dubbed the "hello world" of databases.
libSQL is a fork of SQLite that aims to be a modern database, with a focus on low query latency and high availability. It's designed to be a drop-in replacement for SQLite, and scales globally with Turso over HTTP.
<CardGroup cols={2}>
<Card title="tursodatabase/libsql" icon="github" href="https://github.com/tursodatabase/libsql/">
Browse the libSQL source code on GitHub, report issues, feature requests and contribute using pull requests.
</Card>
<Card title="Discord" href="https://discord.gg/turso" icon="discord">
Join the community on Discord to talk about the development of libSQL.
</Card>
</CardGroup>
## Why fork SQLite?
SQLite is [open-source, not open-contribution](https://www.sqlite.org/copyright.html), which makes it difficult to innovate and evolve with it.
Turso is committed to the open-source community, and we welcome contributions to libSQL. We're also committed to keeping libSQL free and open-source, as well rejoining core SQLite if their policy changes.
Read the [libSQL Manifesto](https://turso.tech/libsql-manifesto) for more details.
## Turso vs. libSQL
Turso manages the distribution of libSQL instances, and provides a global HTTP API for querying and managing databases. It also provides a CLI, Web UI and HTTP API for managing databases, and team management.
When you use Turso, you don't need to worry about managing libSQL instances, or configuring replication. You can focus on building your application, and let Turso handle the rest.
[SDKs](/sdk) are fully compatible with libSQL, whether you use self-hosted or Turso-hosted libSQL.
## SQLite Compatibility
libSQL will remain SQLite compatible by providing the same API and file format, but with additional features and optimizations.
## Encryption at rest
libSQL introduces an essential feature for production environments: **encryption at rest**. This feature enhances data security by encrypting database files, making them inaccessible without the correct encryption key.
libSQL's encryption leverages existing, proven encryption solutions, integrating them directly into the fork of SQLite. The encryption is page-based, allowing for efficient data access without decrypting the entire file. Supported encryption standards include SQLCipher (default) and wxSQLite3's AES 256 Bit, with further options for customization per database.
<CodeGroup>
<Snippet file="encryption-at-rest-typescript.mdx" />
<Snippet file="encryption-at-rest-golang.mdx" />
<Snippet file="encryption-at-rest-rust.mdx" />
<Snippet file="encryption-at-rest-python.mdx" />
<Snippet file="encryption-at-rest-flutter.mdx" />
</CodeGroup>
<Note>The encryption key used should be generated and managed by you.</Note>
## Extensions
<Warning>
Extensions are experimental. [Join us on Discord](https://discord.gg/turso) to add your suggestions and feedback.
</Warning>
<Info>
If you're looking to enable vector extensions, you should instead consider
using the native [libSQL vector datatype](/features/ai-and-embeddings).
</Info>
| Extension                                                                     | Version  | Installed | Description                                                                 |
| ----------------------------------------------------------------------------- | -------- | --------- | --------------------------------------------------------------------------- |
| [JSON](https://www.sqlite.org/json1.html)                                     | Built-in | Default   | Work with JSON data in SQLite.                                              |
| [FTS5](https://www.sqlite.org/fts5.html)                                      | Built-in | Default   | Full-text search and indexing.                                              |
| [R\*Tree](https://www.sqlite.org/rtree.html)                                  | Built-in | Default   | Indexing and querying spatial data.                                         |
| [sqlite-vec](https://github.com/asg017/sqlite-vec/tree/v0.1.1)                | 0.1.0    | Opt-in    | The Vector Search successor to `sqlite-vss`.                                |
| [SQLean Crypto](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/crypto.md) | 0.24.1   | Opt-in    | Hashing, message digest, encoding, and decoding.                            |
| [SQLean Fuzzy](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/fuzzy.md)   | 0.24.1   | Opt-in    | Fuzzy string matching and phonetics. A fork of Spellfix1 with improvements. |
| [SQLean Math](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/math.md)     | 0.24.1   | Opt-in    | Advanced mathematical calculations.                                         |
| [SQLean Regexp](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/regexp.md) | 0.24.1   | Opt-in    | Regular expressions with SQLite.                                            |
| [SQLean Stats](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/stats.md)   | 0.24.1   | Opt-in    | Common statistical functions with SQLite.                                   |
| [SQLean Text](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/text.md)     | 0.24.1   | Opt-in    | String manipulation (reverse, split) with SQLite.                           |
| [SQLean UUID](https://github.com/nalgeon/sqlean/blob/0.24.1/docs/uuid.md)     | 0.24.1   | Opt-in    | Limited support for RFC 4122 compliant UUIDs.                               |
You can enable all extensions when creating a new database using the [CLI](/cli/db/create) or [API](/api-reference/databases/create):
<CodeGroup>
```bash Turso CLI
turso db create [database-name] --enable-extensions
```
```bash Platform API
curl -L -X POST 'https://api.turso.tech/v1/organizations/{organizationSlug}/databases' \
-H 'Authorization: Bearer TOKEN' \
-H 'Content-Type: application/json' \
-d '{
"name": "new-database",
"group": "default",
"extensions": "all"
}'
```
</CodeGroup>
If you already have a group created with extensions disabled, you can update all databases in a group to enable extensions:
```bash
turso group update <group-name> --extensions all
```
# Local Development
Source: https://docs.turso.tech/local-development
Build locally using SQLite, libSQL Server or Turso.
Developers can build locally with Turso using either of the following methods:
* [SQLite](#sqlite) — local SQLite database file
* [Turso CLI](#turso-cli) — managed libSQL server
* [Turso Database](#turso-database) — remote Turso database
## Using a dump locally
You can always dump your production database and use it locally for development:
<Steps>
<Step title="Create a dump using the Turso CLI">
```bash
turso db shell your-database .dump > dump.sql
```
</Step>
<Step title="Create SQLite file from dump">
```bash
cat dump.sql | sqlite3 local.db
```
</Step>
<Step title="Connect to SQLite file">
You can use any of the methods below with the `local.db` file, or you can use a new file name if you prefer to create a database from scratch.
</Step>
</Steps>
## SQLite
There are a few things to keep in mind when using SQLite for local development:
* Doesn't have all the features of libSQL
* Works with non-serverless based Turso SDKs
When working with an [SDK](/sdk), you can pass it a `file:` URL to connect to a SQLite database file instead of a remote Turso database:
<CodeGroup>
```ts JavaScript
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:local.db",
});
```
```rust Rust
let client = libsql_client::Client::from_config(libsql_client::Config {
url: url::Url::parse("file:local.db").unwrap(),
auth_token: None,
})
.await
.unwrap();
```
```go Go
package main
import (
"database/sql"
"fmt"
"os"
_ "github.com/tursodatabase/go-libsql"
)
func main() {
dbName := "file:./local.db"
db, err := sql.Open("libsql", dbName)
if err != nil {
fmt.Fprintf(os.Stderr, "failed to open db %s", err)
os.Exit(1)
}
defer db.Close()
}
```
```python Python
import libsql_client
client = libsql_client.create_client_sync(
url="file:local.db"
)
```
</CodeGroup>
<br />
<Info>
You don't need to provide an `authToken` in development.
</Info>
<Info>
It's recommended to use environment variables for both `url` and `authToken` for a seamless developer experience.
</Info>
## Turso CLI
If you're using [libSQL](/libsql) specific features like [extensions](/libsql#extensions), you should use the Turso CLI:
```bash
turso dev
```
This will start a local libSQL server and create a database for you. You can then connect to it using the `url` option in your SDK:
<CodeGroup>
```ts JavaScript
import { createClient } from "@libsql/client";
const client = createClient({
url: "http://127.0.0.1:8080",
});
```
```rust Rust
let client = libsql_client::Client::from_config(libsql_client::Config {
url: url::Url::parse("http://127.0.0.1:8080").unwrap(),
auth_token: None,
})
.await
.unwrap();
```
```python Python
import libsql_client
client = libsql_client.create_client_sync(
url="http://127.0.0.1:8080"
)
```
</CodeGroup>
<br />
<Warning>
Changes will be lost when you stop the server.
</Warning>
If you want to persist changes, or use a production dump, you can pass the `--db-file` flag with the name of the SQLite file:
```bash
turso dev --db-file local.db
```
## Turso Database
If you already have a database created with Turso, you can use that same one in development by passing the `url` option to your SDK.
<Warning>
Keep in mind that using the Turso hosted database will incur platform costs and count towards your quota. Consider using [SQLite](#sqlite) or [Turso CLI](#turso-cli) for local development to avoid platform costs.
</Warning>
## Connecting a GUI
During development you can easily connect to a SQLite, libSQL, or Turso database using one of the tools below:
* [Beekeeper Studio](https://www.beekeeperstudio.io/db/libsql-client/) — macOS, Linux, and Windows
* [Outerbase](https://www.outerbase.com) — Runs in the browser
* [TablePlus](https://tableplus.com) — macOS, Windows, and Linux
* [Dataflare](https://dataflare.app) — Paid (with limited free version) macOS, Windows, and Linux
* [Outerbase Studio](https://libsqlstudio.com) - Runs in the browser
* [DBeaver](https://dbeaver.io) - macOS, Windows, and Linux
# Quickstart
Source: https://docs.turso.tech/quickstart
Welcome to Turso! Get started with Turso in minutes.
**In this quickstart you will learn how to:**
1. Install the Turso CLI
2. Signup to Turso
3. Create your first Turso Database
4. Connect to Database Shell
<Steps>
<Step title="Install the Turso CLI">
We'll be using the Turso CLI throughout this quickstart to manage databases, create replicas in other regions, and connect to the database shell.
<CodeGroup>
```bash macOS
brew install tursodatabase/tap/turso
```
```bash Linux
curl -sSfL https://get.tur.so/install.sh | bash
```
```bash Windows
curl -sSfL https://get.tur.so/install.sh | bash
```
</CodeGroup>
</Step>
<Step title="Signup to Turso">
The next command will open your browser to sign up:
<CodeGroup>
```bash Signup
turso auth signup
```
```bash Login
turso auth login
```
</CodeGroup>
</Step>
<Step title="Create a Database">
Now create your first database in a location closest to you with the name `my-db`:
```bash
turso db create my-db
```
The Turso CLI automatically detected your closest region to create a database. It used this location to create a `default` "group" for your database, which you can inspect using the following command:
```bash
turso db show my-db
```
</Step>
<Step title="Connect to Database Shell">
Congratulations, you created a database! Now connect to it with the `shell` command:
```bash
turso db shell my-db
```
<Info>
Replace `my-db` with the name of your database if you named it differently.
</Info>
<AccordionGroup>
<Accordion title="Create table">
Now create a table for `users` using SQL:
```sql
CREATE TABLE users (
ID INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT
);
```
</Accordion>
<Accordion title="Insert into new table">
Then insert a row into the `users` table:
```sql
INSERT INTO users (name) VALUES ("Iku");
```
</Accordion>
<Accordion title="Select all rows from table">
Finally, query for all `users`:
```sql
SELECT * FROM users;
```
</Accordion>
</AccordionGroup>
When you're ready to move onto the next step, you'll want to to quit the shell:
```sql
.quit
```
</Step>
<Step title="Connect your application to your database">
You're now ready to connect your application to your database. Pick from one of the SDKs below to continue:
<Snippet file="all-sdks.mdx" />
</Step>
</Steps>
# Ruby on Rails + Turso
Source: https://docs.turso.tech/sdk/activerecord/guides/rails
Set up Turso in your Ruby on Rails project in minutes.
<Snippet file="technical-preview-banner.mdx" />
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Rails app — [learn more](https://guides.rubyonrails.org/getting_started.html)
<Steps>
<Step title="Install the libsql_activerecord Rubygem">
Add the following to your Gemfile:
```ruby
gem 'libsql_activerecord'
```
Then run:
```bash
bundle install
```
</Step>
<Step title="Configure database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
Add your Turso credentials to your Rails credentials file or environment variables.
</Step>
<Step title="Use the libsql adapter">
```yml
default: &default
adapter: libsql
pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
development:
<<: *default
url: <%= ENV['TURSO_DATABASE_URL'] %>
auth_token: <%= ENV['TURSO_AUTH_TOKEN'] %>
path: storage/development.sqlite3 # For embedded replica
```
</Step>
<Step title="Create and run migrations">
Generate a migration:
```bash
rails generate migration CreateProducts name:string description:text
```
Run the migration:
```bash
rails db:migrate
```
</Step>
<Step title="Define models">
Create a model in `app/models/product.rb`:
```ruby
class Product < ApplicationRecord
validates :name, presence: true
end
```
</Step>
<Step title="Use in controllers">
In your controllers, you can now use ActiveRecord methods to interact with your Turso database:
```ruby
class ProductsController < ApplicationController
def index
@products = Product.all
end
def create
@product = Product.new(product_params)
if @product.save
redirect_to @product, notice: 'Product was successfully created.'
else
render :new
end
end
private
def product_params
params.require(:product).permit(:name, :description)
end
end
```
</Step>
<Step title="Execute raw SQL (if needed)">
You can also execute raw SQL queries:
```ruby
results = ActiveRecord::Base.connection.execute("SELECT * FROM products")
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Ruby on Rails App" icon="github" href="https://github.com/tursodatabase/libsql-activerecord/tree/main/examples/railsapp">
See the full source code
</Card>
</CardGroup>
# Turso Quickstart (ActiveRecord)
Source: https://docs.turso.tech/sdk/activerecord/quickstart
Get started with Turso and ActiveRecord in a few simple steps.
<Snippet file="technical-preview-banner.mdx" />
In this Ruby quickstart we will learn how to:
* Retrieve database credentials
* Install the libSQL ActiveRecord gem
* Connect to a local or remote Turso database
* Define and create models
* Perform basic CRUD operations
* Execute raw SQL queries
* Work with migrations
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Install">
In your Ruby project, add the following gems to your Gemfile:
```ruby
gem 'libsql_activerecord'
gem 'activerecord'
```
Then run:
```bash
bundle install
```
</Step>
<Step title="Connect">
Create a Ruby file (e.g., `database.rb`) to set up the database connection:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```rb
require 'libsql_activerecord'
require 'active_record'
ActiveRecord::Base.establish_connection(
adapter: 'libsql',
url: ENV['TURSO_DATABASE_URL'],
auth_token: ENV['TURSO_AUTH_TOKEN'],
path: 'path/to/local/replica.db'
)
```
</Accordion>
<Accordion title="Local only">
```rb
require 'libsql_activerecord'
require 'active_record'
ActiveRecord::Base.establish_connection(
adapter: 'libsql',
path: 'path/to/local.db'
)
```
</Accordion>
<Accordion title="Remote only">
```rb
require 'libsql_activerecord'
require 'active_record'
ActiveRecord::Base.establish_connection(
adapter: 'libsql',
url: ENV['TURSO_DATABASE_URL'],
auth_token: ENV['TURSO_AUTH_TOKEN']
)
```
</Accordion>
<Accordion title="In-memory">
```rb
require 'libsql_activerecord'
require 'active_record'
ActiveRecord::Base.establish_connection(adapter: 'libsql')
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Define models">
Create model files for your database tables. For example, `product.rb`:
```rb
class Product < ActiveRecord::Base
validates :name, presence: true
end
```
</Step>
<Step title="Create and execute a migration">
Create a migration file (e.g., `001_create_products.rb`):
```rb
class CreateProducts < ActiveRecord::Migration[8.0]
def change
create_table :products do |t|
t.string :name
t.text :description
t.timestamps
end
end
end
```
Execute the migration:
```rb
require_relative 'database'
require_relative '001_create_products'
CreateProducts.migrate(:up)
```
</Step>
<Step title="Execute">
Perform some basic CRUD operations:
<CodeGroup>
```rb Create
product = Product.create(name: 'Book', description: 'A book about books')
```
```rb Read
all_products = Product.all
first_product = Product.first
found_product = Product.find_by(name: 'Book')
```
```rb Update
product.update(description: 'An updated description')
```
```rb Delete
product.destroy
```
```rb Raw SQL
results = ActiveRecord::Base.connection.execute("SELECT * FROM products WHERE name LIKE '%Book%'")
results.each do |row|
puts row.inspect
end
```
</CodeGroup>
</Step>
<Step title="Work with associations">
Define associations in your models:
```ruby
class Author < ActiveRecord::Base
has_many :books
end
class Book < ActiveRecord::Base
belongs_to :author
end
```
Use associations in your code:
```ruby
author = Author.create(name: 'Jane Doe')
book = author.books.create(title: 'My First Book')
puts author.books.count # => 1
puts book.author.name # => "Jane Doe"
```
</Step>
</Steps>
# Authentication
Source: https://docs.turso.tech/sdk/authentication
SDKs connect to Turso using the `libsql://` protocol, unless using the [HTTP API](/sdk/http).
## Database URL
You can find your database URL using the [Turso CLI](/cli/db/show) or [Platform API](/api-reference/databases/retrieve), it looks something like this:
<CodeGroup>
```bash libSQL
libsql://[DB-NAME]-[ORG-NAME].turso.io
```
```bash HTTPS
https://[DB-NAME]-[ORG-NAME].turso.io
```
</CodeGroup>
<br />
<Info>
WebSockets generally offer better performance when maintaining an open socket for multiple queries, whereas HTTP is typically more efficient for single queries due to reduced client-server round trips — it's advisable to benchmark both to ascertain the best option for your specific needs.
</Info>
## Auth Tokens
SDKs require an auth token, unless [working locally](/local-development). You can create a new token for your database (or group) using the [Turso CLI](/cli) and [Platform API](/api-reference).
Using Turso CLI and Platform API you can:
* Create tokens for a one database or all databases in a group
* Create `full-access` and `read-only` tokens
* Set expiration for tokens
* Invalidate all tokens
# Turso Examples (C)
Source: https://docs.turso.tech/sdk/c/examples
| Example                                                                                     | Description                                                                             |
| ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| [local](https://github.com/tursodatabase/libsql-c/tree/master/examples/local)               | Uses libsql with a local SQLite file. Creates database, inserts data, and queries.      |
| [remote](https://github.com/tursodatabase/libsql-c/tree/master/examples/remote)             | Connects to a remote database. Requires environment variables for URL and auth token.   |
| [sync](https://github.com/tursodatabase/libsql-c/tree/master/examples/sync)                 | Demonstrates synchronization between local and remote databases.                        |
| [batch](https://github.com/tursodatabase/libsql-c/tree/master/examples/batch)               | Executes multiple SQL statements in a single batch operation.                           |
| [transactions](https://github.com/tursodatabase/libsql-c/tree/master/examples/transactions) | Shows transaction usage: starting, performing operations, and committing/rolling back.  |
| [memory](https://github.com/tursodatabase/libsql-c/tree/master/examples/memory)             | Uses an in-memory SQLite database for temporary storage or fast access.                 |
| [vector](https://github.com/tursodatabase/libsql-c/tree/master/examples/vector)             | Works with vector embeddings, storing and querying for similarity search.               |
| [encryption](https://github.com/tursodatabase/libsql-c/tree/master/examples/encryption)     | Creates and uses an encrypted SQLite database, demonstrating setup and data operations. |
# Turso Quickstart (C)
Source: https://docs.turso.tech/sdk/c/quickstart
Get started with Turso and C using the libSQL client in a few simple steps.
<Snippet file="technical-preview-banner.mdx" />
In this C quickstart we will learn how to:
* Retrieve database credentials
* Install the libSQL package
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Snippet file="mobile-secrets-warning.mdx" />
</Step>
<Step title="Install">
To use libSQL with C, you need to build the library from source:
<Card title="libSQL C" href="https://github.com/tursodatabase/libsql">
Build from source code
</Card>
After building, make sure to link against the library when compiling your C program:
```bash
gcc -o your_program your_program.c -L/path/to/libsql/lib -llibsql
```
</Step>
<Step title="Connect">
You must first initialize libSQL, create a `libsql_database_t` object, and then open a `libsql_connection_t` to it:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```c
#include "libsql.h"
libsql_setup((libsql_config_t){0});
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.path = "local.db",
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN",
.sync_interval = 300
});
libsql_connection_t conn = libsql_database_connect(db);
```
</Accordion>
<Accordion title="Local only">
```c
#include "libsql.h"
libsql_setup((libsql_config_t){0});
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.path = "local.db"
});
libsql_connection_t conn = libsql_database_connect(db);
```
</Accordion>
<Accordion title="Remote only">
```c
#include "libsql.h"
libsql_setup((libsql_config_t){0});
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN"
});
libsql_connection_t conn = libsql_database_connect(db);
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database by preparing a statement and then executing it:
```c
libsql_statement_t stmt = libsql_connection_prepare(conn, "SELECT * FROM users");
libsql_rows_t rows = libsql_statement_query(stmt);
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```c Positional Query
libsql_statement_t stmt = libsql_connection_prepare(conn, "SELECT * FROM users WHERE id = ?");
libsql_statement_bind_value(stmt, libsql_integer(1));
libsql_rows_t rows = libsql_statement_query(stmt);
```
```c Positional Insert
libsql_statement_t stmt = libsql_connection_prepare(conn, "INSERT INTO users (id) VALUES (?)");
libsql_statement_bind_value(stmt, libsql_integer(1));
libsql_execute_t result = libsql_statement_execute(stmt);
```
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas, you should call `libsql_database_sync()` on the database to sync your local database with the primary database, unless you are using `sync_interval` (though there is no issue with calling `sync` with `sync_interval` enabled):
```c
libsql_sync_t sync = libsql_database_sync(db);
if (sync.err) {
fprintf(stderr, "Error syncing database: %s\n", libsql_error_message(sync.err));
} else {
printf("Sync completed. Frame number: %llu, Frames synced: %llu\n",
(unsigned long long)sync.frame_no,
(unsigned long long)sync.frames_synced);
}
```
</Step>
</Steps>
# C Reference
Source: https://docs.turso.tech/sdk/c/reference
libSQL C Reference
<Snippet file="technical-preview-banner.mdx" />
## Installing
To use the libSQL C bindings, you need to include the `libsql.h` header file in your project and link against the `liblibsql.so` shared library.
<Card title="libSQL C" href="https://github.com/tursodatabase/libsql">
Build from source code
</Card>
Before using libSQL, you need to call the setup function:
```c
libsql_setup((libsql_config_t){0});
```
## In-Memory Databases
libSQL supports connecting to \[in-memory
databases]\([https://www.sqlite.org/inmemorydb.htm](https://www.sqlite.org/inmemorydb.htm) databases for cases where you don't require persistence:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){.path = ":memory:"});
libsql_connection_t conn = libsql_database_connect(db);
```
## Local Development
You can work locally using an SQLite file:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){.path = "local.db"});
libsql_connection_t conn = libsql_database_connect(db);
```
## Remote Databases
You can connect to remote databases using a URL and auth token:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN"
});
libsql_connection_t conn = libsql_database_connect(db);
```
## Embedded Replicas
You can work with embedded replicas that can sync from the remote URL and delegate writes to the remote primary database:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.path = "local.db",
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN"
});
libsql_connection_t conn = libsql_database_connect(db);
```
### Manual Sync
The `libsql_database_sync` function allows you to sync manually the local database with the remote counterpart:
```c
libsql_sync_t sync = libsql_database_sync(db);
```
### Sync Interval
The `sync_interval` parameter in the database description allows you to set an interval for automatic synchronization of the database in the background:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.path = "local.db",
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN",
.sync_interval = 60000
});
```
### Read Your Own Writes
The `not_read_your_writes` parameter in the database description configures the database connection to ensure that writes are immediately visible to subsequent read operations initiated by the same connection. This is **enabled by default**, and you can disable it by setting `not_read_your_writes` to `true`:
```c
libsql_database_t db = libsql_database_init((libsql_database_desc_t){
.path = "local.db",
.url = "TURSO_DATABASE_URL",
.auth_token = "TURSO_AUTH_TOKEN",
.not_read_your_writes = true
});
```
## Simple query
You can use `libsql_connection_batch` for simple queries without parameters:
```c
libsql_batch_t batch = libsql_connection_batch(conn, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)");
```
For queries with results, use `libsql_connection_prepare` and `libsql_statement_query`:
```c
libsql_statement_t stmt = libsql_connection_prepare(conn, "SELECT * FROM users");
libsql_rows_t rows = libsql_statement_query(stmt);
```
## Prepared Statements
You can prepare a statement using `libsql_connection_prepare` and then execute it with `libsql_statement_execute` or `libsql_statement_query`:
```c
libsql_statement_t stmt = libsql_connection_prepare(conn, "INSERT INTO users (name) VALUES (?)");
libsql_statement_bind_value(stmt, libsql_text("John Doe", 8));
libsql_execute_t result = libsql_statement_execute(stmt);
```
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```c Positional
libsql_statement_t stmt = libsql_connection_prepare(conn, "SELECT * FROM users WHERE id = ?");
libsql_statement_bind_value(stmt, libsql_integer(1));
```
```c Named
libsql_statement_t stmt = libsql_connection_prepare(conn, "SELECT * FROM users WHERE id = :id");
libsql_statement_bind_named(stmt, ":id", libsql_integer(1));
```
</CodeGroup>
## Transactions
libSQL supports transactions:
```c
libsql_transaction_t tx = libsql_connection_transaction(conn);
// Perform operations within the transaction
libsql_transaction_commit(tx); // or libsql_transaction_rollback(tx)
```
## Cleanup
Remember to clean up resources when you're done:
```c
libsql_statement_deinit(stmt);
libsql_connection_deinit(conn);
libsql_database_deinit(db);
```
# Examples
Source: https://docs.turso.tech/sdk/flutter/examples
# Drift + Turso / LibSQL
Source: https://docs.turso.tech/sdk/flutter/integrations/drift
Configure `drift` to work with `libsql_dart`
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
<Steps>
<Step title="Add packages to your project">
```bash
flutter pub add drift_libsql drift drift_flutter dev:build_runner dev:drift_dev
```
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Create a table schema">
```dart
class TaskTable extends Table {
IntColumn get id => integer().autoIncrement()();
TextColumn get title => text()();
TextColumn get description => text()();
BoolColumn get completed => boolean()();
}
```
</Step>
<Step title="Create db class">
```dart
@DriftDatabase(tables: [TaskTable])
class AppDatabase extends _$AppDatabase {
AppDatabase(super.e);
@override
int get schemaVersion => 1;
}
```
</Step>
<Step title="Run build runner">
```bash
dart run build_runner build
```
</Step>
<Step title="Create the db">
```dart
final db = AppDatabase(DriftLibsqlDatabase(
"${dir.path}/replica.db",
syncUrl: url,
authToken: token,
readYourWrites: true,
syncIntervalSeconds: 3,
));
```
</Step>
<Step title="Perform SQL operations">
```dart
await db.into(db.taskTable).insert(TaskTableCompanion.insert(
title: task.title,
description: task.description,
completed: task.completed));
```
</Step>
</Steps>
# Turso Quickstart (Flutter / Dart)
Source: https://docs.turso.tech/sdk/flutter/quickstart
Get started with Flutter and Dart using the libSQL client in a few simple steps
<Note>
This SDK is community maintained and may not be officially supported by Turso, or up to date with the latest features. Join the `#libsql-dart` channel [on Discord](https://discord.gg/turso) for help and feedback.
</Note>
In this Flutter/Dart quickstart we will learn how to:
* Retrieve database credentials
* Install the Flutter/Dart libSQL client
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install libsql_dart">
```bash
flutter pub add libsql_dart
```
</Step>
<Step title="Initialize">
Now connect to your local or remote database using the `LibsqlClient` constructor:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```dart
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path)
..authToken = '<TOKEN>'
..syncUrl = '<TURSO_OR_LIBSQL_URL>'
..syncIntervalSeconds = 5
..readYourWrites = true;
```
</Accordion>
<Accordion title="Local only">
<CodeGroup>
```dart File
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path);
```
```dart In-Memory
final client = LibsqlClient(":memory:");
```
</CodeGroup>
</Accordion>
<Accordion title="Remote only">
```dart
final client = LibsqlClient('<TURSO_OR_LIBSQL_URL>')
..authToken = '<TOKEN>';
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Connect">
```dart
await client.connect();
```
</Step>
<Step title="Execute">
<CodeGroup>
```dart Execute
await client.execute("create table if not exists customers (id integer primary key, name text);");
```
```dart Insert
await client.query("insert into customers(name) values ('John Doe')");
```
```dart Select
print(await client.query("select * from customers"));
```
```dart Batch
await client.batch("""insert into customers (name) values ('Jane Doe'); insert into customers (name) values ('Jake Doe');""");
```
```dart Prepared statement
final statement = await client
.prepare("select * from customers where id = ?");
await statement.query(positional: [1])
```
```dart Interactive transaction
final tx = await client.transaction();
await tx
.execute("update customers set name = 'John Noe' where id = 1");
await tx
.execute("update customers set name = 'Jane Noe' where id = 2");
print(await tx
.query("select * from customers where id = ?", positional: [1]));
await tx.commit();
```
</CodeGroup>
If you need to use placeholders for values, you can do that:
<CodeGroup>
```dart Positional
final statement = await client
.prepare("select * from customers where id = ?");
await statement.query(positional: [1])
```
```dart Named
final statement = await client
.prepare("select * from customers where id = :id");
await statement.query(named: {"id": 1})
```
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the connector to sync your local database with the primary database.
```dart
await client.sync();
```
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/flutter/reference
libSQL Flutter / Dart Reference
The libSQL package for Flutter / Dart contains everything you need to work with Turso / libSQL and works flawlessly with all features, because it’s build on top libSQL Rust crate and `flutter_rust_bridge` package, allowing for seamless communication between Rust and Dart.
## Add the package to your project
```bash
flutter pub add libsql_dart
```
Alternatively, manually add it to your project's `pubspec.yaml`
```yaml
libsql_dart:
```
## Initializing
Call `LibsqlClient` constructor to create the database client. Different configurations are supported, allowing connection to in-memory database, local sqlite file, remote Turso / libSQL database, or embedded replica.
## In-Memory Databases
libSQL supports connecting to [in-memory databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't require persistence:
```dart
final client = LibsqlClient(":memory:");
```
## Local Development
You can work locally using an SQLite file and passing the path to `LibsqlClient`:
```dart
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path);
```
## Remote
You can work with remote database by passing your Turso Database URL:
```dart
final client = LibsqlClient('<TURSO_OR_LIBSQL_URL>')
..authToken = '<TOKEN>';
```
## Embedded Replicas
You can work with embedded replicas by passing your Turso Database URL to `syncUrl`:
```dart
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path)
..authToken = '<TOKEN>'
..syncUrl = '<TURSO_OR_LIBSQL_URL>'
..readYourWrites = true;
```
<Snippet file="embedded-replicas-warning.mdx" />
### Connect
```dart
await client.connect();
```
### Manual Sync
The `sync()` function allows you to sync manually the local database with the remote counterpart:
```ts
await client.sync();
```
### Periodic Sync
You can automatically sync at intervals by configuring the `syncIntervalSeconds` property when instantiating the client:
```dart
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path)
..authToken = '<TOKEN>'
..syncUrl = '<TURSO_OR_LIBSQL_URL>'
..syncIntervalSeconds = 5
..readYourWrites = true;
```
### Encryption at rest
To enable encryption on a SQLite file, pass the `encryptionKey`:
```dart
final dir = await getApplicationCacheDirectory();
final path = '${dir.path}/local.db';
final client = LibsqlClient(path)..encryptionKey = '<KEY>';
```
Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations — [learn more](/libsql#encryption-at-rest).
## Execute
Returns number of rows affected:
```dart
await client.execute("create table if not exists customers (id integer primary key, name text);");
```
## Query
Returns rows as `List<Map<String, dynamic>>`. Will returns empty list when is not performing select query:
```dart
await client.query("insert into customers(name) values ('John Doe')");
print(await client.query("select * from customers"));
```
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```dart Positional
final statement = await client
.prepare("select * from customers where id = ?");
await statement.query(positional: [1])
```
```dart Named
final statement = await client
.prepare("select * from customers where id = :id");
await statement.query(named: {"id": 1})
```
</CodeGroup>
<br />
<Info>
libSQL supports the same named placeholder characters as SQLite — `:`, `@` and `$`.
</Info>
## Batch Transactions
A batch consists of multiple SQL statements executed sequentially within an implicit transaction. The backend handles the transaction: success commits all changes, while any failure results in a full rollback with no modifications.
```dart
await client.batch("""insert into customers (name) values ('Jane Doe'); insert into customers (name) values ('Jake Doe');""");
```
## Transaction Modes
| Mode                                  | SQLite command               | Description                                                                                                                                                                                        |
| ------------------------------------- | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `LibsqlTransactionBehavior.immediate` | `BEGIN IMMEDIATE`            | The transaction may execute statements that read and write data. Write transactions executed on a replica are forwarded to the primary instance, and can't operate in parallel.                    |
| `LibsqlTransactionBehavior.readOnly`  | `BEGIN TRANSACTION READONLY` | The transaction may only execute statements that read data (select). Read transactions can occur on replicas, and can operate in parallel with other read transactions.                            |
| `LibsqlTransactionBehavior.deferred_` | `BEGIN DEFERRED`             | The transaction starts in read mode, then changes to write as soon as a write statement is executed. This mode change may fail if there is a write transaction currently executing on the primary. |
## Interactive Transactions
Interactive transactions in SQLite ensure the consistency of a series of read and write operations within a transaction's scope. These transactions give you control over when to commit or roll back changes, isolating them from other client activity.
| Method       | Description                                                         |
| ------------ | ------------------------------------------------------------------- |
| `execute()`  | Similar to `execute()` except within the context of the transaction |
| `query()`    | Similar to `query()` except within the context of the transaction   |
| `commit()`   | Commits all write statements in the transaction                     |
| `rollback()` | Rolls back the entire transaction                                   |
```dart
final tx = await client.transaction();
await tx
.execute("update customers set name = 'John Noe' where id = 1");
await tx
.execute("update customers set name = 'Jane Noe' where id = 2");
print(await tx
.query("select * from customers where id = ?", positional: [1]));
await tx.commit();
```
<br />
<Warning>
Interactive transactions in libSQL lock the database for writing until
committed or rolled back, with a 5-second timeout. They can impact performance
on high-latency or busy databases.
</Warning>
## ATTACH
You can attach multiple databases to the current connection using the `ATTACH` attachment:
```dart
final tx = await client.transaction(behavior: LibsqlTransactionBehavior.readOnly);
await tx.execute("ATTACH "<database-id>" AS attached");
print(await tx.execute("SELECT * FROM attached.customers"));
await tx.commit();
```
<Info>
Make sure to [allow `ATTACH`](/cli/db/config/attach/allow) and create a token
with the permission to attach a database — [learn
more](/features/attach-database)
</Info>
# Examples
Source: https://docs.turso.tech/sdk/go/examples
# Turso Quickstart (Go)
Source: https://docs.turso.tech/sdk/go/quickstart
Get started with Turso and Go using the libSQL client in a few simple steps.
The libSQL package is designed to work with [`database/sql`](https://pkg.go.dev/database/sql) to provide the usual methods you'd expect when working with databases in Go.
<Info>
The `go-libsql` package uses CGO. You can use `github.com/tursodatabase/libsql-client-go/libsql` instead, but it doesn't support embedded replicas.
</Info>
In this Go quickstart we will learn how to:
* Retrieve database credentials
* Install Go libSQL
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install">
First begin by adding libSQL to your project:
<AccordionGroup>
<Accordion title="Local / Embedded Replicas">
```bash
go get github.com/tursodatabase/go-libsql
```
</Accordion>
<Accordion title="Remote only">
```bash
go get github.com/tursodatabase/libsql-client-go/libsql
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Connect">
Now connect to your local or remote database using the libSQL connector:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```go
package main
import (
"database/sql"
"fmt"
"os"
"path/filepath"
"github.com/tursodatabase/go-libsql"
)
func main() {
dbName := "local.db"
primaryUrl := "libsql://[DATABASE].turso.io"
authToken := "..."
dir, err := os.MkdirTemp("", "libsql-*")
if err != nil {
fmt.Println("Error creating temporary directory:", err)
os.Exit(1)
}
defer os.RemoveAll(dir)
dbPath := filepath.Join(dir, dbName)
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
)
if err != nil {
fmt.Println("Error creating connector:", err)
os.Exit(1)
}
defer connector.Close()
db := sql.OpenDB(connector)
defer db.Close()
}
```
</Accordion>
<Accordion title="Local only">
```go
package main
import (
"database/sql"
"fmt"
"os"
_ "github.com/tursodatabase/go-libsql"
)
func main() {
dbName := "file:./local.db"
db, err := sql.Open("libsql", dbName)
if err != nil {
fmt.Fprintf(os.Stderr, "failed to open db %s", err)
os.Exit(1)
}
defer db.Close()
}
```
</Accordion>
<Accordion title="Remote only">
```go
package main
import (
"database/sql"
"fmt"
"os"
_ "github.com/tursodatabase/libsql-client-go/libsql"
)
func main() {
url := "libsql://[DATABASE].turso.io?authToken=[TOKEN]"
db, err := sql.Open("libsql", url)
if err != nil {
fmt.Fprintf(os.Stderr, "failed to open db %s: %s", url, err)
os.Exit(1)
}
defer db.Close()
}
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database. Create a function to query your database that accepts the pointer to `sql.DB` as an argument:
```go
type User struct {
ID   int
Name string
}
func queryUsers(db *sql.DB)  {
rows, err := db.Query("SELECT * FROM users")
if err != nil {
fmt.Fprintf(os.Stderr, "failed to execute query: %v\n", err)
os.Exit(1)
}
defer rows.Close()
var users []User
for rows.Next() {
var user User
if err := rows.Scan(&user.ID, &user.Name); err != nil {
fmt.Println("Error scanning row:", err)
return
}
users = append(users, user)
fmt.Println(user.ID, user.Name)
}
if err := rows.Err(); err != nil {
fmt.Println("Error during rows iteration:", err)
}
}
```
Now inside `func main()` call `queryUsers` and pass in the pointer to `sql.DB`:
```go
queryUsers(db)
```
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `Sync()` on the connector to sync your local database with the primary database.
```go
if err := connector.Sync(); err != nil {
fmt.Println("Error syncing database:", err)
}
```
The connector can automatically sync your database at a regular interval when using the `WithSyncInterval` option:
```go
syncInterval := time.Minute
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
libsql.WithSyncInterval(syncInterval),
)
```
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/go/reference
## Embedded Replicas
You can work with [embedded replicas](/features/embedded-replicas) that can sync from the remote database to a local SQLite file, and delegate writes to the remote primary database:
```go
package main
import (
"database/sql"
"fmt"
"os"
"path/filepath"
"github.com/tursodatabase/go-libsql"
)
func main() {
dbName := "local.db"
primaryUrl := "libsql://[DATABASE].turso.io"
authToken := "..."
dir, err := os.MkdirTemp("", "libsql-*")
if err != nil {
fmt.Println("Error creating temporary directory:", err)
os.Exit(1)
}
defer os.RemoveAll(dir)
dbPath := filepath.Join(dir, dbName)
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken)
)
if err != nil {
fmt.Println("Error creating connector:", err)
os.Exit(1)
}
defer connector.Close()
db := sql.OpenDB(connector)
defer db.Close()
}
```
<Snippet file="embedded-replicas-warning.mdx" />
### Manual Sync
The `Sync` function allows you to sync manually the local database with the remote counterpart:
```go
if err := connector.Sync(); err != nil {
fmt.Println("Error syncing database:", err)
}
```
### Periodic Sync
You can automatically sync at intervals using `WithSyncInterval` and passing a `time.Duration` as an argument. For example, to sync every minute, you can use the following code:
```go
syncInterval := time.Minute
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
libsql.WithSyncInterval(syncInterval),
)
```
### Read Your Writes
By default, the database connection ensures that writes are immediately visible to subsequent read operations initiated by the same connection.
You can disable this behaviour using `WithReadYourWrites(false)`:
```go
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
libsql.WithReadYourWrites(false),
)
```
## Encryption
To enable encryption on a SQLite file, pass the encryption key value as an argument to the constructor:
```go
encryptionKey := "SuperSecretKey"
connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, primaryUrl,
libsql.WithAuthToken(authToken),
libsql.WithEncryption(encryptionKey),
)
```
<Info>
Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations — [learn more](/libsql#encryption-at-rest).
</Info>
# Turso Quickstart (HTTP)
Source: https://docs.turso.tech/sdk/http/quickstart
Get started with Turso using the libSQL remote protocol in a few simple steps.
In this HTTP quickstart we will learn how to:
* Obtain HTTP URL for a Turso database
* Create a database auth token
* Connect to a remote Turso database
* Execute a SQL using the [libSQL remote protocol](https://github.com/tursodatabase/libsql/blob/main/docs/HRANA_3_SPEC.md#hrana-over-http)
<Steps>
<Step title="Create HTTP Database URL">
Using the [Turso CLI](/cli) or [Platform API](/api-reference), fetch your database URL:
```bash
turso db show <database-name> --http-url
```
<Info>
Append `/v2/pipeline` to the URL and continue.
</Info>
</Step>
<Step title="Create Database Auth Token">
Using the Turso CLI or Platform API, create a new auth token for your database:
```bash
turso db tokens create <database-name>
```
</Step>
<Step title="Create JSON Request Payload">
We'll be sending the query using JSON, so let's create a JSON payload that executes a SQL statement and closes the connection immediately:
```json
{
"requests": [
{ "type": "execute", "stmt": { "sql": "SELECT * FROM users" } },
{ "type": "close" }
]
}
```
<Info>
Make sure to update the `stmt.sql` to select from a table you already have.
Bound parameter examples included on the [Reference Page](/sdk/http/reference#parameter-binding),
</Info>
</Step>
<Step title="Execute HTTP Request">
Depending on your language, you can use a HTTP client library to send the request to the URL you created as well as the `Authorization` header set to the token you created, and the request body as JSON with your SQL statement.
You must append to the Base URL the actual pipeline URL that accepts requests — `/v2/pipeline`.
<CodeGroup>
```ts JavaScript (Fetch)
const url = "https://[databaseName]-[organizationSlug].turso.io/v2/pipeline";
const authToken = "...";
fetch(url, {
method: "POST",
headers: {
Authorization: `Bearer ${authToken}`,
"Content-Type": "application/json",
},
body: JSON.stringify({
requests: [
{ type: "execute", stmt: { sql: "SELECT * FROM users" } },
{ type: "close" },
],
}),
})
.then((res) => res.json())
.then((data) => console.log(data))
.catch((err) => console.log(err));
```
```ruby Ruby
require 'net/http'
require 'json'
require 'uri'
url = "https://[databaseName]-[organizationSlug].turso.io/v2/pipeline"
auth_token = "..."
uri = URI(url)
request = Net::HTTP::Post.new(uri)
request["Authorization"] = "Bearer #{auth_token}"
request["Content-Type"] = "application/json"
request.body = JSON.generate({
"requests": [
{ "type": "execute", "stmt": { "sql": "SELECT * FROM users" } },
{ "type": "close" }
]
})
begin
response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: uri.scheme == 'https') do |http|
http.request(request)
end
puts JSON.parse(response.body)
rescue => e
puts e.message
end
```
</CodeGroup>
<br />
<Accordion title="Response">
The response will be a JSON object with a `results` array containing the results of your query that looks something like this:
```json
{
"baton": null,
"base_url": null,
"results": [
{
"type": "ok",
"response": {
"type": "execute",
"result": {
"cols": [],
"rows": [],
"affected_row_count": 0,
"last_insert_rowid": null,
"replication_index": "1"
}
}
},
{
"type": "ok",
"response": {
"type": "close"
}
}
]
}
```
</Accordion>
If you need to use placeholders for values, you can do that:
<CodeGroup>
```json Positional
{
"type": "execute",
"stmt": {
"sql": "SELECT * FROM users WHERE id = ?",
"args": [
{
"type": "integer",
"value": "1"
}
]
}
}
```
```json Named
{
"type": "execute",
"stmt": {
"sql": "SELECT * FROM users WHERE name = :name OR name = $second_name OR name = @third_name",
"named_args": [
{
"name": "name",
"value": {
"type": "text",
"value": "Turso"
}
},
{
"name": "second_name",
"value": {
"type": "text",
"value": "Not Turso"
}
},
{
"name": "third_name",
"value": {
"type": "text",
"value": "Maybe Turso"
}
}
]
}
}
```
</CodeGroup>
<Info>
The `type` field within each arg corresponds to the column datatype and can be one of the following: `null`, `integer`, `float`, `text`, or `blob`.
</Info>
<Note>
In JSON, the `value` is a `String` to avoid losing precision, because some
JSON implementations treat all numbers as 64-bit floats.
</Note>
</Step>
</Steps>
# libSQL Remote Protocol Reference
Source: https://docs.turso.tech/sdk/http/reference
Turso Databases can be accessed via HTTP. The API enable developers to perform SQL operations using the [libSQL remote protocol](https://github.com/tursodatabase/libsql/blob/main/docs/HTTP_V2_SPEC.md), retrieve server version information, and monitor the health status.
<Info>
It's recommended you use a [native SDK](/sdk).
</Info>
## Base URL
Simply replace your database URL protocol `libsql://` with `https://`:
```bash
https://[databaseName]-[organizationSlug].turso.io
```
You can obtain your database base URL from the Turso CLI:
<Accordion title="Obtain HTTP URL using Turso CLI">
```bash
turso db show <database-name> --http-url
```
</Accordion>
## Authentication
Turso uses Bearer authentication, and requires your API token to be passed with all protected requests in the `Authorization` header:
```bash
Authorization: Bearer TOKEN
```
<Accordion title="Create token using Turso CLI">
```bash
turso db tokens create <database-name>
```
</Accordion>
## Endpoints
Your database has the endpoints available below:
### `POST /v2/pipeline`
You can use the `/v2/pipeline` endpoint to query a database. The endpoint accepts a series of operations to perform against a database connection. The supported operation types are:
* `execute`: execute a statement on the connection.
* `close`: close the connection.
#### Simple query
<CodeGroup>
```json Request
{
"requests": [
{ "type": "execute", "stmt": { "sql": "CREATE TABLE users (name)" } },
{ "type": "close" }
]
}
```
```json Response
{
"baton": null,
"base_url": null,
"results": [
{
"type": "ok",
"response": {
"type": "execute",
"result": {
"cols": [],
"rows": [],
"affected_row_count": 0,
"last_insert_rowid": null,
"replication_index": "1"
}
}
},
{
"type": "ok",
"response": {
"type": "close"
}
}
]
}
```
</CodeGroup>
<br />
<Info>
Connections are left open until they timeout, unless you close them explicitly in the request (as shown above). Every request made on a connection bumps the timeout. You should close the connection when it's no longer needed.
</Info>
#### Parameter binding
Queries with bound parameters come in two types:
1. Positional query parameters, bound by their position in the parameter list, and prefixed `?`. If the query uses positional parameters, the values should be provided as an array to the `args` field.
<CodeGroup>
```json Request
{
"requests": [
{
"type": "execute",
"stmt": {
"sql": "SELECT * FROM users WHERE name = ?",
"args": [
{
"type": "text",
"value": "Turso"
}
]
}
},
{
"type": "close"
}
]
}
```
```json Response
{
"baton": null,
"base_url": null,
"results": [
{
"type": "ok",
"response": {
"type": "execute",
"result": {
"cols": [
{
"name": "name",
"decltype": "TEXT"
}
],
"rows": [
[
{
"type": "text",
"value": "Turso"
}
]
],
"affected_row_count": 0,
"last_insert_rowid": null
}
}
},
{
"type": "ok",
"response": {
"type": "close"
}
}
]
}
```
</CodeGroup>
<br />
2. Named bound parameters, where the parameter is referred to by a name and is prefixed with a `:`, a `@` or a `$`. If the query uses named parameters, then the `named_args` field of the query should be an array of objects mapping parameters to their values.
<CodeGroup>
```json Request
{
"requests": [
{
"type": "execute",
"stmt": {
"sql": "SELECT * FROM users WHERE name = :name OR name = $second_name OR name = @third_name",
"named_args": [
{
"name": "name",
"value": {
"type": "text",
"value": "Turso"
}
},
{
"name": "second_name",
"value": {
"type": "text",
"value": "Not Turso"
}
},
{
"name": "third_name",
"value": {
"type": "text",
"value": "Maybe Turso"
}
}
]
}
},
{
"type": "close"
}
]
}
```
```json Response
{
"baton": null,
"base_url": null,
"results": [
{
"type": "ok",
"response": {
"type": "execute",
"result": {
"cols": [
{
"name": "name",
"decltype": "TEXT"
}
],
"rows": [
[
{
"type": "text",
"value": "Turso"
}
]
],
"affected_row_count": 0,
"last_insert_rowid": null
}
}
},
{
"type": "ok",
"response": {
"type": "close"
}
}
]
}
```
</CodeGroup>
<br />
<Info>
The `name` property of each `named_args` can match the prefix or omit the prefix. They were omitted in the example above, but both versions are valid.
The `type` field within each arg corresponds to the column datatype and can be one of the following: `null`, `integer`, `float`, `text`, or `blob`.
</Info>
<Info>
If using the `blob` type, replace the `value` property with `base64` and encode the argument into `base64` before sending the request.
</Info>
<Note>
In JSON, the `value` is a `String` to avoid losing precision, because some
JSON implementations treat all numbers as 64-bit floats.
</Note>
#### Interactive query
Sometimes, it may be desirable to perform multiple operation on the same connection, in multiple roundtrips. We can do this by not closing the connection right away:
<CodeGroup>
```json Body
{
"requests": [{ "type": "execute", "stmt": { "sql": "BEGIN" } }]
}
```
```json Response
{
"baton": "m7lVVgEvknpf1P1irxHsHqrAqH7BLiwO4DQIAwr93PdZWGvdBNugLSokSsCZNkry",
"base_url": null,
"results": [
{
"type": "ok",
"response": {
"type": "execute",
"result": {
"cols": [],
"rows": [],
"affected_row_count": 0,
"last_insert_rowid": null,
"replication_index": "1"
}
}
}
]
}
```
</CodeGroup>
We can see that we have received a `baton` back. This is because we haven't closed the connection. We can now use this baton to perform more queries on the same connection:
```json Body
{
"baton": "m7lVVgEvknpf1P1irxHsHqrAqH7BLiwO4DQIAwr93PdZWGvdBNugLSokSsCZNkry",
"requests": [
{ "type": "execute", "stmt": { "sql": "CREATE TABLE users (name)" } },
{
"type": "execute",
"stmt": { "sql": "INSERT INTO users VALUES (\"iku\")" }
},
{ "type": "execute", "stmt": { "sql": "COMMIT" } },
{ "type": "close" }
]
}
```
<Info>
Note that both transactions and connections have timeouts. Transaction have a 5 seconds window to complete, while connections get closed after 10 seconds of idle time.
</Info>
#### Response types
The response contains the following fields:
| Field      | Type   | Description                                                                                                                          |
| ---------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------ |
| `baton`    | string | The baton is used to identify a connection with the server so that it can be reused.                                                 |
| `base_url` | string | The base URL of the server that handled the request. This URL can be reused for subsequent requests to force routing to that server. |
| `results`  | array  | The results for each of the requests made in the pipeline.                                                                           |
The `results` array contains the results for each of the requests made in the pipeline. Each result has the following fields:
| Field                | Type    | Description                                                 |
| -------------------- | ------- | ----------------------------------------------------------- |
| `cols`               | array   | The list of columns for the returned rows.                  |
| `rows`               | array   | The rows returned for the query.                            |
| `affected_row_count` | integer | The number of rows affected by the query.                   |
| `last_insert_rowid`  | integer | The ID of the last inserted row.                            |
| `replication_index`  | string  | The replication timestamp at which this query was executed. |
| `rows_read`          | integer | The number of rows read by the query.                       |
| `rows_written`       | integer | The number of rows written by the query.                    |
| `query_duration_ms`  | float   | The duration of the query in milliseconds.                  |
### `GET /version`
To obtain the current version of the server running your database you can use the `/version` endpoint:
<CodeGroup>
```bash Request
curl -L -X GET 'https://[databaseName]-[organizationSlug].turso.io/version' \
-H 'Authorization: Bearer TOKEN'
```
```text 200
sqld 0.21.9 (67f3ea5d 2023-10-26)
```
</CodeGroup>
### `GET /health`
To check the health of your database, you can use the `/health` endpoint which returns an empty body with an HTTP status:
<CodeGroup>
```bash Request
curl -L -X GET 'https://[databaseName]-[organizationSlug].turso.io/health' \
-H 'Authorization: Bearer TOKEN'
```
```text 200
This response has no body data.
```
</CodeGroup>
### `GET /dump`
You can dump the database using the `/dump` endpoint:
<CodeGroup>
```bash Request
curl -L -X GET 'https://[databaseName]-[organizationSlug].turso.io/dump' \
-H 'Authorization: Bearer TOKEN'
```
```text 200
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS mytable (
content TEXT,
embedding FLOAT32(1536)
);
CREATE TABLE IF NOT EXISTS libsql_vector_index (type TEXT, name TEXT, vector_type TEXT, block_size INTEGER, dims INTEGER, distance_ops TEXT);
INSERT INTO libsql_vector_index VALUES('diskann','mytable_idx','float32',128,1536,'cosine');
CREATE INDEX mytable_idx USING diskann_cosine_ops ON mytable (embedding);
COMMIT;
```
</CodeGroup>
If you're using [multi-db schemas](/features/multi-db-schemas), or vector databases, you will see statements that represent internally managed tables.
## Schema Migration Status
Turso provides a managed multi-tenant schema system — [Multi-DB Schemas](/features/multi-db-schemas). This feature allows you to create a single database that shares its schema automatically with any related child databases. Changes to the parent database automatically propogate to the related databases.
The `/v1/jobs` endpoint lets you monitor the status of schema migrations.
<Warning>
Currently not available on AWS for Free, Hobby and Scaler plans.
</Warning>
### `GET /v1/jobs`
Returns a summary of all migration jobs for a schema:
<CodeGroup>
```bash Request
curl -X GET 'https://[databaseName]-[organizationSlug].turso.io/v1/jobs' \
-H 'Authorization: Bearer TOKEN'
```
```json Example Response
{
"schema_version": 4,
"migrations": [
{
"job_id": 43,
"status": "RunSuccess"
},
{
"job_id": 42,
"status": "RunSuccess"
},
{
"job_id": 39,
"status": "RunSuccess"
}
]
}
```
</CodeGroup>
#### Response Fields
<ResponseField name="schema_version" type="number">
Current version of the schema.
</ResponseField>
<ResponseField name="migrations" type="array">
List of migration jobs
<Expandable title="Migration Object">
<ResponseField name="job_id" type="number">
Unique ID for the migration job.
</ResponseField>
<ResponseField name="status" type="string">
Current status of the job. Possible values: `WaitingDryRun`,
`DryRunSuccess`, `DryRunFailure`, `WaitingRun`, `RunSuccess`, `RunFailure`
</ResponseField>
</Expandable>
</ResponseField>
### `GET /v1/jobs/:id`
Returns detailed information about a specific migration job.
<CodeGroup>
```bash Request
curl -X GET 'https://[databaseName]-[organizationSlug].turso.io/v1/jobs/:id' \
-H 'Authorization: Bearer TOKEN'
```
```json Example Response
{
"job_id": 1,
"status": "RunSuccess",
"error": null,
"progress": [
{
"namespace": "db1",
"status": "Success",
"error": null
},
{
"namespace": "db2",
"status": "Failure",
"error": "Connection lost"
}
]
}
```
</CodeGroup>
#### Path Parameters
<ParamField path="id" type="number" required>
The ID of the migration job.
</ParamField>
#### Response Fields
<ResponseField name="job_id" type="number">
Unique ID of the migration job.
</ResponseField>
<ResponseField name="status" type="string">
Overall status of the job. Possible values are the same as in the `/v1/jobs`
endpoint.
</ResponseField>
<ResponseField name="error" type="string">
Error message if the job failed, null otherwise.
</ResponseField>
<ResponseField name="progress" type="array">
List of migration statuses for the individual databases.
<Expandable title="Progress Object">
<ResponseField name="namespace" type="string">
Name of the database.
</ResponseField>
<ResponseField name="status" type="string">
Status of migration for this database. Possible values: `Enqueued`,
`DryRunSuccess`, `DryRunFailure`, `Run`, `Success`, `Failure`
</ResponseField>
<ResponseField name="error" type="string">
Error message if migration failed for this database, null otherwise.
</ResponseField>
</Expandable>
</ResponseField>
## Listen to changes
You can listen to changes committed to your database using the `/beta/listen` endpoint:
<Snippet file="technical-preview-banner.mdx" />
<Warning>Currently not available on AWS for Free, Hobby and Scaler plans.</Warning>
<Info>
Your database group must be using the version `v0.24.18` or greater — `turso group update <group-name> --version latest`
</Info>
### `GET /beta/listen`
```bash Request
curl -L 'https://[primary-instance-id]-[databaseName]-[organizationSlug].turso.io/beta/listen?table=TABLE_NAME' \
-H 'Authorization: Bearer TOKEN'
```
#### Query Parameters
<ParamField query="table" type="string" required>
The name of the table to listen to.
</ParamField>
<ParamField query="action" type="string" required>
The name of the action to listen to — `insert`, `update`, or `delete`.
</ParamField>
# Introduction
Source: https://docs.turso.tech/sdk/introduction
Turso provides multiple official SDKs that you can use to connect a local or remote database, as well as support for embedded databases. If you're using a language or framework that isn't supported with an official driver, you can use Turso over HTTP.
## Official SDKs
Turso SDKs are fully compatible with [libSQL](/libsql), so you can use the same SDK to connect to a local database ([SQLite](/local-development#sqlite)), [libSQL server](/local-development#libsql-server), a remote database, or an [embedded replica](/features/embedded-replicas).
<Snippet file="official-sdks.mdx" />
## Community SDKs
These SDKs are community-driven and don't come with official Turso support.
<CardGroup cols={2}>
<Card
horizontal
title="Flutter / Dart"
icon={
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
<path
fill="#1ebca1"
d="M429.5 236.3L291.7 374.1 429.5 512H272l-59.1-59.1-78.8-78.8L272 236.3H429.5zM272 0L16 256l78.8 78.8L429.5 0H272z"
/>
</svg>
}
href="/sdk/flutter/quickstart"
/>
<Card horizontal title="React Native / OP-SQLite" icon="react" href="https://ospfranco.notion.site/OP-SQLite-Documentation-a279a52102464d0cb13c3fa230d2f2dc?pvs=4" />
<Card
horizontal
title="Laravel"
icon={
<svg
xmlns="http://www.w3.org/2000/svg"
preserveAspectRatio="xMidYMid"
viewBox="0 0 256 264"
>
<path
d="m255.9 59.6.1 1.1v56.6c0 1.4-.8 2.8-2 3.5l-47.6 27.4v54.2c0 1.4-.7 2.8-2 3.5l-99.1 57-.7.4-.3.1c-.7.2-1.4.2-2.1 0l-.4-.1-.6-.3L2 206c-1.3-.8-2.1-2.2-2.1-3.6V32.7l.1-1.1.2-.4.3-.6.2-.4.4-.5.4-.3c.2 0 .3-.2.5-.3L51.6.6c1.3-.8 2.9-.8 4.1 0L105.3 29c.2 0 .3.2.4.3l.5.3c0 .2.2.4.3.5l.3.4.3.6.1.4.2 1v106l41.2-23.7V60.7c0-.4 0-.7.2-1l.1-.4.3-.7.3-.3.3-.5.5-.3.4-.4 49.6-28.5c1.2-.7 2.8-.7 4 0L254 57l.5.4.4.3.4.5.2.3c.2.2.2.5.3.7l.2.3Zm-8.2 55.3v-47l-17.3 10-24 13.7v47l41.3-23.7Zm-49.5 85v-47l-23.6 13.5-67.2 38.4v47.5l90.8-52.3ZM8.2 39.9V200l90.9 52.3v-47.5l-47.5-26.9-.4-.4c-.2 0-.3-.1-.4-.3l-.4-.4-.3-.4-.2-.5-.2-.5v-.6l-.2-.5V63.6L25.6 49.8l-17.3-10Zm45.5-31L12.4 32.8l41.3 23.7 41.2-23.7L53.7 8.9ZM75 157.3l24-13.8V39.8l-17.3 10-24 13.8v103.6l17.3-10ZM202.3 36.9 161 60.7l41.3 23.8 41.3-23.8-41.3-23.8Zm-4.1 54.7-24-13.8-17.3-10v47l24 13.9 17.3 10v-47Zm-95 106 60.6-34.5 30.2-17.3-41.2-23.8-47.5 27.4L62 174.3l41.2 23.3Z"
fill="#1ebca1"
/>
</svg>
}
href="https://github.com/richan-fongdasen/turso-laravel"
/>
<Card horizontal title=".NET" icon="microsoft" href="https://github.com/tvandinther/libsql-client-dotnet" />
<Card horizontal title="Java" icon="java" href="https://github.com/dbeaver/dbeaver-jdbc-libsql" />
<Card horizontal title="Stateless libSQL" icon="github" href="https://github.com/DaBigBlob/libsql-stateless-easy" />
</CardGroup>
## Turso over HTTP
<CardGroup cols={2}>
<Snippet file="http-sdk.mdx" />
</CardGroup>
# Turso Quickstart (Android)
Source: https://docs.turso.tech/sdk/kotlin/quickstart
Get started with Turso and Android using the libSQL client in a few simple steps.
<Snippet file="technical-preview-banner.mdx" />
<Note>
This will only work with the Android Gradle Plugin for now. Fully Kotlin
support is coming.
</Note>
In this Kotlin quickstart we will learn how to:
* Retrieve database credentials
* Add libSQL as a dependency in your Android Gradle project
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Snippet file="mobile-secrets-warning.mdx" />
</Step>
<Step title="Install">
Add libsql as a implementation dependency in Gradle:
<Note>
This will only work with the Android Gradle Plugin for now.
</Note>
```kotlin
dependencies {
implementation("tech.turso.libsql:libsql:0.1.0")
}
```
</Step>
<Step title="Connect">
You must first create a `Database` object and then open a `Connection` to it:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(
path = "./local.db",
url = "TURSO_DATABASE_URL",
authToken = "TURSO_AUTH_TOKEN",
)
val conn = db.connect()
```
</Accordion>
<Accordion title="Local only">
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(path = "./local.db")
val conn = db.connect()
```
</Accordion>
<Accordion title="Remote only">
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(
url = "TURSO_DATABASE_URL",
authToken = "TURSO_AUTH_TOKEN",
)
val conn = db.connect()
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database by calling `execute()`:
```kotlin
db.connect().use {
it.execute("INSERT INTO users (id) VALUES (1)")
}
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```kotlin Positional
db.connect().use {
it.query("SELECT * FROM users WHERE id = ?", 1)
}
```
```kotlin Named
db.connect().use {
it.query("INSERT INTO users (name) VALUES (:name)", mapOf(":name" to "Iku"))
}
```
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the database type to
sync your local database with the primary database, unless you are using
`syncInterval` (though there is no issue with calling `sync` with
`syncInterval` enabled):
```kotlin
db.sync()
```
</Step>
</Steps>
# Android Reference
Source: https://docs.turso.tech/sdk/kotlin/reference
libSQL Android Reference
<Snippet file="technical-preview-banner.mdx" />
<Note>
This will only work with the Android Gradle Plugin for now. Fully Kotlin
support is coming.
</Note>
## Installing
Add libsql as a implementation dependency in Gradle:
```kotlin
dependencies {
implementation("tech.turso.libsql:libsql:0.1.0")
}
```
## In-Memory Databases
libSQL supports connecting to [in-memory
databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't
require persistence:
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(":memory:")
val conn = db.connect()
```
## Local Development
You can work locally using an SQLite file:
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(path = "./local.db")
val conn = db.connect()
```
## Embedded Replicas
You can work with embedded replicas that can sync from the remote URL and
delegate writes to the remote primary database:
```kotlin
import tech.turso.libsql.Libsql
val db = Libsql.open(
path = "./local.db",
url = "TURSO_DATABASE_URL",
authToken = "TURSO_AUTH_TOKEN",
)
val conn = db.connect()
```
### Manual Sync
The `sync` function allows you to sync manually the local database with the
remote counterpart:
```kotlin
db.sync() // Call sync manually to update local database (only for EmbeddedReplicaDatabase)
```
## Simple query
You can pass a string to `query()` to invoke a SQL statement, as well as
optional arguments:
<CodeGroup>
```kotlin Execute
db.connect().use {
it.execute("INSERT INTO users VALUES (?)", 1)
}
```
```kotlin Query
db.connect().use {
it.query("INSERT INTO users VALUES (?)", 1)
}
```
```kotlin Arguments
db.connect().use {
it.query("SELECT * FROM users WHERE id = ?", 1)
}
```
</CodeGroup>
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
```kotlin Positional
db.connect().use {
it.query("SELECT * FROM users WHERE id = ?", 1)
}
```
```kotlin Named
db.connect().use {
it.query("SELECT * FROM users WHERE id = :id", mapOf(":id" to 1))
}
```
## Batch Transactions
A batch consists of multiple SQL statements executed sequentially within an
implicit transaction. The backend handles the transaction: success commits all
changes, while any failure results in a full rollback with no modifications.
```kotlin
db.connect().use {
it.execute_batch("
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY,
name TEXT NOT NULL
);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
")
}
```
## Transactions
Interactive transactions in SQLite ensure the consistency of a series of read
and write operations within a transaction's scope. These transactions give you
control over when to commit or roll back changes, isolating them from other
client activity.
```kotlin
db.connect().use {
val tx = it.transaction();
tx.execute("INSERT INTO users (name) VALUES (?)", "Iku");
tx.execute("INSERT INTO users (name) VALUES (?)", "Iku 2");
tx.commit() // or tx.rollback()
}
```
# Examples
Source: https://docs.turso.tech/sdk/php/examples
[View examples on GitHub](https://github.com/tursodatabase/libsql-client-ts/tree/main/packages/libsql-client/examples)
# Turso Quickstart (Laravel)
Source: https://docs.turso.tech/sdk/php/guides/laravel
In this Laravel quickstart we will learn how to:
* Install the Turso Laravel adapter
* Configure Laravel to use Turso
* Create a model and migration
* Perform CRUD operations using Eloquent
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install">
Install the package to your Laravel project using Composer:
```console
composer require turso/libsql-laravel
```
<Info>Make sure to enable FFI in your PHP configuration to use the Laravel adapter.</Info>
</Step>
<Step title="Configure">
Choose your preferred setup and configure accordingly:
<AccordionGroup>
<Accordion title="Local only">
Update your `config/database.php`:
```php
return [
"default" => env("DB_CONNECTION", "libsql"),
"connections" => [
"libsql" => [
"driver" => "libsql",
"database" => database_path("database.db"),
],
// ...
],
];
```
This will use a local SQLite file with the libSQL adapter.
</Accordion>
<Accordion title="Remote only">
Update your `config/database.php`:
```php
return [
"default" => env("DB_CONNECTION", "libsql"),
"connections" => [
"libsql" => [
"driver" => "libsql",
"url" => env("TURSO_DATABASE_URL"),
"password" => env("TURSO_AUTH_TOKEN"),
],
// ...
],
];
```
Then add to your `.env` file:
```
DB_CONNECTION=libsql
TURSO_DATABASE_URL=libsql://...
TURSO_AUTH_TOKEN=...
```
</Accordion>
<Accordion title="Embedded Replicas">
Update your `config/database.php`:
```php
return [
"default" => env("DB_CONNECTION", "libsql"),
"connections" => [
"libsql" => [
"driver" => "libsql",
"database" => database_path("database.db"),
"url" => env("TURSO_DATABASE_URL"),
"password" => env("TURSO_AUTH_TOKEN"),
"sync_interval" => env("TURSO_SYNC_INTERVAL", 300),
],
// ...
],
];
```
Then add to your `.env` file:
```
DB_CONNECTION=libsql
TURSO_DATABASE_URL=libsql://...
TURSO_AUTH_TOKEN=...
TURSO_SYNC_INTERVAL=300
```
<Info>The `sync_interval` is optional and defaults to 300 seconds (5 minutes).</Info>
<Warning>Support for Embedded Replicas on AWS is coming soon</Warning>
</Accordion>
</AccordionGroup>
</Step>
<Step title="Create a model and migration">
Create a User model and migration:
```console
php artisan make:model User -m
```
Update the migration file:
```php
public function up()
{
Schema::create('users', function (Blueprint $table) {
$table->id();
$table->string('name');
$table->string('email')->unique();
$table->timestamps();
});
}
```
</Step>
<Step title="Run migrations">
Apply the migration to create the users table:
```console
php artisan migrate
```
</Step>
<Step title="Execute CRUD operations">
Now you can perform CRUD operations using Eloquent:
<CodeGroup>
```php Create
use App\Models\User;
$user = User::create([
'name' => 'John Doe',
'email' => 'john@example.com',
]);
```
```php Read
use App\Models\User;
// Fetch all users
$allUsers = User::all();
// Find a specific user by ID
$user = User::find(1);
// Filter users
$filteredUsers = User::where('name', 'John Doe')->get();
```
```php Update
use App\Models\User;
// Update a single record
$user = User::find(1);
$user->name = 'Jane Doe';
$user->save();
// Update multiple records
User::where('name', 'John Doe')->update(['name' => 'Jane Doe']);
```
```php Delete
use App\Models\User;
// Delete a single record
$user = User::find(1);
$user->delete();
// Delete multiple records
User::where('name', 'Jane Doe')->delete();
```
</CodeGroup>
</Step>
</Steps>
# Turso + Doctrine DBAL
Source: https://docs.turso.tech/sdk/php/orm/doctrine-dbal
Set up Turso in your PHP + Doctrine DBAL project in minutes
![Doctrine DBAL](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/doctrine-dbal-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an PHP Application with Doctrine DBAL
<Snippet file="install-libsql-extension-php.mdx" />
<Steps>
<Step title="Configure database credentials">
Get the database URL:
```bash
turso db show --url <database-name>
```
Get the database authentication token:
```bash
turso db tokens create <database-name>
```
Assign credentials to the environment variables inside `.env`.
```bash
TURSO_DATABASE_URL=
TURSO_AUTH_TOKEN=
```
<Info>Save this later when you need to connect to **Remote** and **Embedded Replica**</Info>
</Step>
<Step title="Create PHP Project">
Create new directory:
```bash
mkdir your-awesome-php-project
cd your-awesome-php-project
```
</Step>
<Step title="Install Turso Doctrine DBAL">
```bash
composer require tursodatabase/turso-doctrine-dbal
```
</Step>
<Step title="Configure database connection">
Setup the environment variable in your Laravel application, choose what the type connection you need.
<CodeGroup>
```php In-Memory Only
$params = [
"url"               => ":memory:",
'driverClass'       => \Turso\Doctrine\DBAL\Driver::class,
];
```
```php Local Only
$params = [
"url"               => "database.db",
'driverClass'       => \Turso\Doctrine\DBAL\Driver::class,
];
```
```php Remote Only
$params = [
"auth_token"        => getenv('TURSO_AUTH_TOKEN'),
"sync_url"          => getenv('TURSO_DATABASE_URL'),
'driverClass'       => \Turso\Doctrine\DBAL\Driver::class,
];
```
```php Embedded Replica
$params = [
"url"               => "database.db",
"auth_token"        => getenv('TURSO_AUTH_TOKEN'),
"sync_url"          => getenv('TURSO_DATABASE_URL'),
'driverClass'       => \Turso\Doctrine\DBAL\Driver::class,
];
```
</CodeGroup>
**Other environment variables (Embedded Replica Only)**
<Expandable title="Other environment variables (Embedded Replica Only)">
<ResponseField name="sync_interval" type="integer">
Integer value representing synchronization interval in seconds (optional, default: `5`).
</ResponseField>
<ResponseField name="read_your_writes" type="boolean">
Boolean value indicating whether to read your writes (optional, default: `true`).
</ResponseField>
<ResponseField name="encryption_key" type="string">
String value for encryption purposes (optional, default: empty).
</ResponseField>
</Expandable>
</Step>
<Step title="Project Structure Example">
```bash
src/
├── helpers.php
└── Todo.php
vendor/
composer.json
composer.lock
todo            # todo executable
```
Here you simple php todo cli + Doctrine BDAL
<CodeGroup>
```php todo
#!/usr/bin/env php
<?php
use Turso\Todo\CLI\Todo;
require_once __DIR__ . '/vendor/autoload.php';
$header = 'TODO CLI + TURSO';
echo $header . PHP_EOL;
function main()
{
echo str_repeat('-', WIDTH - 18) . "  Todo CLI - " . VERSION . PHP_EOL;
while (true) {
echo "[L] List | [A] Add | [E] Edit | [D] Delete | [X] Exit" . PHP_EOL;
echo "command: ";
$choice = trim(fgets(STDIN));
$app = new Todo();
switch (strtolower($choice)) {
case 'l':
$app->listTodos();
break;
case 'a':
$app->addTodo();
clearScreen();
break;
case 'e':
$app->editTodo();
clearScreen();
break;
case 'd':
$app->deleteTodo();
clearScreen();
break;
case 'x':
exit("Goodbye!" . PHP_EOL);
default:
echo "Invalid choice." . PHP_EOL;
clearScreen();
}
}
echo PHP_EOL;
}
main();
```
```php src/helpers.php
<?php
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\DriverManager;
const WIDTH = 100;
const VERSION = '1.0.0';
function clearScreen()
{
if (strtoupper(substr(PHP_OS, 0, 3)) === 'WIN') {
system('cls');
} else {
system('clear');
}
}
function createConnection(): Connection
{
$params = [
"auth_token"        => getenv('TURSO_AUTH_TOKEN'),
"sync_url"          => getenv('TURSO_DATABASE_URL'),
'driverClass'       => \Turso\Doctrine\DBAL\Driver::class,
];
$db = DriverManager::getConnection($params);
return $db;
}
```
```php src/Todo.php
<?php
namespace Turso\Todo\CLI;
use Doctrine\DBAL\Connection;
class Todo
{
private Connection $db;
public function __construct()
{
$this->db = createConnection();
}
public function loadTodos(): array
{
$sql = "SELECT * FROM todos";
return $this->db->fetchAllAssociative($sql);
}
public function saveTodo(string $todo): void
{
$sql = "INSERT INTO todos (name) VALUES (?)";
$this->db->executeStatement($sql, [$todo]);
}
public function updateTodo(int $id, string $todo): void
{
$sql = "UPDATE todos SET name = ? WHERE id = ?";
$this->db->executeStatement($sql, [$todo, $id]);
}
public function removeTodo(int $id): void
{
$sql = "DELETE FROM todos WHERE id = ?";
$this->db->executeStatement($sql, [$id]);
}
public function listTodos()
{
$todos = $this->loadTodos();
echo "\n" . "TODO-List   " . str_repeat('-', WIDTH - 12) . "\n\n";
if (!empty($todos)) {
foreach ($todos as $todo) {
echo sprintf("[%d] %s\n", $todo['id'], $todo['name']);
}
} else {
echo "Nothing...\n";
}
echo "\n" . str_repeat('-', WIDTH) . "\n";
}
public function addTodo()
{
echo "Enter the new To-Do: ";
$todo = trim(fgets(STDIN));
$this->saveTodo($todo);
echo "To-Do added.\n";
}
public function editTodo()
{
$this->listTodos();
echo "Enter the number of the To-Do to edit: ";
$index = intval(trim(fgets(STDIN)));
$findTodo = $this->db->executeQuery("SELECT * FROM todos WHERE id = ?", [$index])->fetchAssociative();
if (!empty($findTodo)) {
echo "Enter the new value: ";
$todo = trim(fgets(STDIN));
$this->updateTodo($findTodo['id'], $todo);
echo "To-Do updated.\n";
} else {
echo "Invalid index.\n";
}
}
public function deleteTodo()
{
$this->listTodos();
echo "Enter the number of the To-Do to delete: ";
$index = intval(trim(fgets(STDIN)));
$findTodo = $this->db->executeQuery("SELECT * FROM todos WHERE id = ?", [$index])->fetchAssociative();
if (!empty($findTodo)) {
$this->removeTodo($findTodo['id']);
echo "To-Do deleted.\n";
} else {
echo "Invalid index.\n";
}
}
}
```
</CodeGroup>
</Step>
<Step title="Your PHP Application Ready!">
![PHP TODO CLI - TURSO](https://i.imgur.com/dmrPFr2.png)
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="PHP Todo CLI + Doctrine DBAL" icon="github" href="https://github.com/tursodatabase/example/php-todo-cli-doctrine-dbal/tree/master">
See the full source code
</Card>
<Card title="Symfony Rest API CRUD" icon="github" href="https://github.com/tursodatabase/example/symfony7-rest-api-crud/tree/master">
See the full source code
</Card>
</CardGroup>
# Turso Quickstart (PHP)
Source: https://docs.turso.tech/sdk/php/quickstart
Get started with Turso and PHP using the libSQL client in a few simple steps.
In this PHP quickstart we will learn how to:
* Install libSQL with Composer
* Retrieve database credentials
* Connect to a Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create
one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install">
Install the package to your project using composer:
```console
composer require turso/libsql
```
</Step>
<Step title="Connect">
Now connect to your local or remote database using the libSQL connector:
<AccordionGroup>
<Accordion title="Embedded Replica">
```php
use Libsql\Database;
$db = new Database(
path: 'test.db',
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN')
syncInterval: 100 // Sync every second
);
$conn = $db->connect();
```
</Accordion>
<Accordion title="Local only">
```php
use Libsql\Database;
$db = new Database(path: "database.db");
```
Or just:
```php
use Libsql\Database;
$db = new Database("database.db");
```
</Accordion>
<Accordion title="Local only">
```php
use Libsql\Database;
$db = new Database(path: "database.db");
```
Or just:
```php
use Libsql\Database;
$db = new Database("database.db");
```
</Accordion>
<Accordion title="Remote only">
```php
use Libsql\Database;
$db = new Database(
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
)
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute SQL queries against your existing database as follows:
```php
$createUsers = "
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY AUTOINCREMENT,
name TEXT,
age INTEGER
);
INSERT INTO users (name, age) VALUES ('Prof. Ir. Onno Widodo Purbo, M.Eng., Ph.D', 61);
INSERT INTO users (name, age) VALUES ('Jim Geovedi', 41);
INSERT INTO users (name, age) VALUES ('Nasirun', 59);
";
$db->executeBatch($createUsers);
$db->query("SELECT * FROM users")->fetchArray();
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```php Positional
$db->query("SELECT * FROM users WHERE id = ?", [1])->fetchArray();
```
```php Named
$db->query("SELECT * FROM users WHERE id = :id", [":id" => 1])->fetchArray();
```
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the database type
to sync your local database with the primary database:
```php
<?php
$db->sync();
```
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/php/reference
libSQL PHP Reference
## Installing
Install the package to your project using composer:
```console
composer require turso/libsql
```
## Initializing
Make sure to add `use Libsql\Database` to access the `Database` object.
```php
$db = new Database("local.db")
```
## In-Memory Databases
libSQL supports connecting to [in-memory
databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't
require persistence:
```php
$db = new Database(":memory:");
```
Or the simpler:
```php
$db = new Database();
```
## Local Development
You can work locally by passing a path as the first parameter.
```php
$db = new Database("local.db")
```
Or more explicitly:
```php
$db = new Database(path: "local.db")
```
## Remote Only
You can use a remote only database by passing `url` and `authToken`.
```php
$db = new Database(
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
);
```
## Embedded Replicas
You can work with embedded replicas by passing a `path`, `url` and `authToken`.
Embedded replicas can sync from the remote URL and delegate writes to the
remote primary database:
```php
$db = new Database(
path: 'test.db',
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
);
```
### Sync Interval
The `sync_interval` function allows you to set an interval for automatic synchronization of the database in the background:
```php
$db = new Database(
path: 'test.db',
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
syncInterval: 300, // Sync every 3 seconds
);
```
### Manual Sync
The `sync` function allows you to sync manually the local database with the
remote counterpart:
```php
$db->sync()
```
### Read Your Own Writes
The `readYourWrites` parameter configures the database connection to ensure
that writes are immediately visible to subsequent read operations initiated by
the same connection. This is **enabled by default**, and is particularly
important in distributed systems to ensure consistency from the perspective of
the writing process.
You can disable this behavior by passing `false`:
```php
$db = new Database(
path: 'test.db',
url: getenv('TURSO_URL'),
authToken: getenv('TURSO_AUTH_TOKEN'),
readYourWrites: false,
);
```
## Simple Query
You can acquire a connection from a database and call `query()` to invoke a
SQL statement, as well as optional arguments:
<CodeGroup>
```php Query
$rows = $conn->query("SELECT * FROM users");
```
```php Arguments
$rows = $conn->query("SELECT * FROM users WHERE id = ?1", [1]);
```
```php Named Arguments
$rows = $conn->query("SELECT * FROM users WHERE id = :id", [":id" => 1]);
```
</CodeGroup>
## Prepared Statements
You can prepare a cached statement using `prepare()`, bind parameters, and then
query it:
```php
$stmt = $conn->prepare("SELECT * FROM users where id = ?");
$rows = $stmt->bind([1])->query();
```
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```rust Positional
conn->query("SELECT * FROM users WHERE id = ?", [1]);
```
```rust Named
conn->execute("INSERT INTO users (name) VALUES (:name)", [ ":name" => "Iku" ]);
```
</CodeGroup>
## Batch Transactions
A batch consists of multiple SQL statements executed sequentially within an
implicit transaction. The backend handles the transaction: success commits all
changes, while any failure results in a full rollback with no modifications.
```php
$conn->execute_batch("
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY,
name TEXT NOT NULL
);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
");
```
## Interactive Transactions
Interactive transactions in SQLite ensure the consistency of a series of read
and write operations within a transaction's scope. These transactions give you
control over when to commit or roll back changes, isolating them from other
client activity.
```php
$tx = conn->transaction();
$tx->execute("INSERT INTO users (name) VALUES (?1)", ["Iku"]);
$tx->execute("INSERT INTO users (name) VALUES (?1)", ["Iku 2"]);
tx->commit(); // or, $tx->rollback()
```
# Examples
Source: https://docs.turso.tech/sdk/python/examples
# Flask + Turso
Source: https://docs.turso.tech/sdk/python/guides/flask
Set up Turso in your Flask project in minutes
![Flask banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/flask-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Flask app — [learn more](https://flask.palletsprojects.com/en/3.0.x/installation/#create-an-environment)
<Steps>
<Step title="Install the libSQL dialect">
```bash
pip install sqlalchemy-libsql python-dotenv
```
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Create database models">
```python models.py
from sqlalchemy import String
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
class Base(DeclarativeBase):
pass
class Item(Base):
__tablename__ = "items"
id: Mapped[str] = mapped_column(primary_key=True)
foo: Mapped[str] = mapped_column(String(255))
bar: Mapped[str] = mapped_column(String(100))
def __repr__(self) -> str:
return f"Item(id={self.id!r}, foo={self.foo!r}, bar={self.bar!r})"
```
</Step>
<Step title="Query">
```python
from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.orm import Session
from sqlalchemy import select
from models import Item
load_dotenv()
# Get environment variables
TURSO_DATABASE_URL = os.environ.get("TURSO_DATABASE_URL")
TURSO_AUTH_TOKEN = os.environ.get("TURSO_AUTH_TOKEN")
# construct special SQLAlchemy URL
dbUrl = f"sqlite+{TURSO_DATABASE_URL}/?authToken={TURSO_AUTH_TOKEN}&secure=true"
engine = create_engine(dbUrl, connect_args={'check_same_thread': False}, echo=True)
@app.route("/", methods=(["GET"]))
def home():
session = Session(engine)
# get & print items
stmt = select(Item)
for item in session.scalars(stmt):
print(item)
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Social App" icon="github" href="https://github.com/turso-extended/app-find-me-on-python-htmx/tree/master">
See the full source code
</Card>
</CardGroup>
# SQLAlchemy + Turso
Source: https://docs.turso.tech/sdk/python/orm/sqlalchemy
Configure SQLAlchemy to work with your Turso database
![SQLAlchemy Quickstart](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/sqlalchemy-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
<Steps>
<Step title="Install the libSQL dialect for SQLAlchemy">
```bash
pip install sqlalchemy-libsql
```
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Create database models">
```python models.py
from sqlalchemy import String
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
class Base(DeclarativeBase):
pass
class Foo(Base):
__tablename__ = "foo"
id: Mapped[str] = mapped_column(primary_key=True)
bar: Mapped[str] = mapped_column(String(100))
def __repr__(self) -> str:
return f"Item(id={self.id!r}, bar={self.bar!r})"
```
</Step>
<Step title="Construct SQLAlchemy URL for Turso">
```py app.py
from dotenv import load_dotenv
from sqlalchemy import create_engine
TURSO_DATABASE_URL = os.environ.get("TURSO_DATABASE_URL")
TURSO_AUTH_TOKEN = os.environ.get("TURSO_AUTH_TOKEN")
dbUrl = f"sqlite+{TURSO_DATABASE_URL}/?authToken={TURSO_AUTH_TOKEN}&secure=true"
engine = create_engine(dbUrl, connect_args={'check_same_thread': False}, echo=True)
```
</Step>
<Step title="Query">
```py app.py
from sqlalchemy.orm import Session
from sqlalchemy import select
from models import Foo
@app.route("/", methods=(["GET"]))
def home():
session = Session(engine)
# get & print foos
stmt = select(Foo)
for item in session.scalars(stmt):
print(item)
```
</Step>
</Steps>
# Turso Quickstart (Python)
Source: https://docs.turso.tech/sdk/python/quickstart
Get started with Turso and Python using the libSQL client in a few simple steps.
In this Python quickstart we will learn how to:
* Retrieve database credentials
* Install the libSQL package
* Connect to a Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install">
First begin by adding libSQL to your project:
```bash
pip install libsql-experimental
```
</Step>
<Step title="Connect">
Then import the package:
```py
import libsql_experimental as libsql
```
Now connect to your local or remote database using the libSQL connector:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```py
url = os.getenv("TURSO_DATABASE_URL")
auth_token = os.getenv("TURSO_AUTH_TOKEN")
conn = libsql.connect("hello.db", sync_url=url, auth_token=auth_token)
conn.sync()
```
</Accordion>
<Accordion title="Local only">
```py
conn = libsql.connect("hello.db")
cur = conn.cursor()
```
</Accordion>
{/* <Accordion title="Remote only">
```py
url = os.getenv("TURSO_DATABASE_URL")
auth_token = os.getenv("TURSO_AUTH_TOKEN")
conn = libsql.connect(database=url, auth_token=auth_token)
```
</Accordion> */}
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute SQL queries against your existing database as follows:
```py
conn.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER);")
conn.execute("INSERT INTO users(id) VALUES (10);")
print(conn.execute("select * from users").fetchall())
```
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the connector to sync your local database with the primary database.
```py
conn.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER);")
conn.execute("INSERT INTO users(id) VALUES (1);")
conn.commit()
conn.sync()
print(conn.execute("select * from users").fetchall())
```
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/python/reference
## Embedded Replicas
You can work with [embedded replicas](/features/embedded-replicas) that can sync from the remote database to a local SQLite file, and delegate writes to the remote primary database:
```py
import os
import libsql_experimental as libsql
conn = libsql.connect("local.db", sync_url=os.getenv("LIBSQL_URL"),
auth_token=os.getenv("LIBSQL_AUTH_TOKEN"))
conn.execute("CREATE TABLE IF NOT EXISTS users (id INTEGER);")
conn.execute("INSERT INTO users(id) VALUES (1);")
conn.commit()
print(conn.execute("select * from users").fetchall())
```
<Snippet file="embedded-replicas-warning.mdx" />
### Periodic Sync
You can automatically sync at intervals by passing time in seconds to the `sync_interval` option. For example, to sync every minute, you can use the following code:
```py
conn = libsql.connect("local.db", sync_interval=60, sync_url=os.getenv("LIBSQL_URL"),
auth_token=os.getenv("LIBSQL_AUTH_TOKEN"))
```
### Manual Sync
The `Sync` function allows you to sync manually the local database with the remote counterpart:
```py
conn.execute("INSERT INTO users(id) VALUES (2);")
conn.commit()
conn.sync()
```
## Encryption
To enable encryption on a SQLite file, pass the encryption secret to the `encryption_key` option:
```py
conn = libsql.connect("encrypted.db", sync_url=os.getenv("LIBSQL_URL"),
auth_token=os.getenv("LIBSQL_AUTH_TOKEN"),
encryption_key=os.getenv("ENCRYPTION_KEY"))
```
<Info>
Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations — [learn more](/libsql#encryption-at-rest).
</Info>
# Turso Examples (Ruby)
Source: https://docs.turso.tech/sdk/ruby/examples
| Example                                                                                        | Description                                                                             |
| ---------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| [local](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/local)               | Uses libsql with a local SQLite file. Creates database, inserts data, and queries.      |
| [remote](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/remote)             | Connects to a remote database. Requires environment variables for URL and auth token.   |
| [sync](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/sync)                 | Demonstrates synchronization between local and remote databases.                        |
| [transactions](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/transactions) | Shows transaction usage: starting, performing operations, and committing/rolling back.  |
| [memory](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/memory)             | Uses an in-memory SQLite database for temporary storage or fast access.                 |
| [vector](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/vector)             | Works with vector embeddings, storing and querying for similarity search.               |
| [encryption](https://github.com/tursodatabase/libsql-ruby/tree/master/examples/encryption)     | Creates and uses an encrypted SQLite database, demonstrating setup and data operations. |
# Turso Quickstart (Ruby)
Source: https://docs.turso.tech/sdk/ruby/quickstart
Get started with Turso and Ruby using the libSQL client in a few simple steps.
<Snippet file="technical-preview-banner.mdx" />
In this Ruby quickstart we will learn how to:
* Retrieve database credentials
* Install the libSQL package
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Snippet file="mobile-secrets-warning.mdx" />
</Step>
<Step title="Install">
Inside your Ruby project, install the following Rubygem:
```bash
bundle add turso_libsql
```
</Step>
<Step title="Connect">
<AccordionGroup>
<Accordion title="Embedded Replicas">
```rb
require 'turso_libsql'
db =Libsql::Database.new(
path: 'local.db',
url: ENV['TURSO_DATABASE_URL'],
auth_token: ENV['TURSO_AUTH_TOKEN'],
sync_interval: 100
)
```
</Accordion>
<Accordion title="Local only">
```rb
require 'turso_libsql'
db = Libsql::Database.new(path: 'local.db')
```
</Accordion>
<Accordion title="Remote only">
```rb
require 'turso_libsql'
db = Libsql::Database.new(
url: ENV['TURSO_DATABASE_URL'],
auth_token: ENV['TURSO_AUTH_TOKEN']
)
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database by preparing a statement and then executing it:
```c
db.connect do |conn|
rows = conn.query 'SELECT * FROM users'
rows.close
end
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```c Positional
name = 'Iku'
rows = conn.execute 'INSERT INTO users (id) VALUES (?)', [name]
```
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas, you should call `sync` on the database to sync your local database with the primary database, unless you are using `sync_interval` (though there is no issue with calling `sync` with `sync_interval` enabled):
```rb
db.sync
```
</Step>
</Steps>
# Examples
Source: https://docs.turso.tech/sdk/rust/examples
# Turso + Actix
Source: https://docs.turso.tech/sdk/rust/guides/actix
Set up Turso in your Actix project in minutes
![Actix banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/actix-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an Actix app — [learn more](https://actix.rs/docs/getting-started)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Add the libsql crate to the project">
```sh
cargo add libsql
```
<Note>
Optionally, you can add a package such as [`dotenvy`](https://docs.rs/dotenvy/latest/dotenvy) to help you work with `.env` files:
```sh
cargo add dotenvy
```
</Note>
</Step>
<Step title="Execute SQL">
```rust
#[tokio::main]
#[actix_web::main]
async fn main() -> std::io::Result<()> {
HttpServer::new(|| App::new().route("/", web::get().to(index)).route("/items", web::get().to(get_items)))
.bind(("127.0.0.1", 8080))?
.run()
.await
}
async fn get_items() -> Result<HttpResponse, Error> {
dotenv().expect(".env file not found");
let db_url = env::var("TURSO_DATABASE_URL").unwrap();
let auth_token = env::var("TURSO_AUTH_TOKEN").unwrap();
let db_file = env::var("LOCAL_DB").unwrap();
let db = Builder::new_remote_replica(db_file, url, auth_token)
.read_your_writes(true)
.build()
.await
.unwrap();
let conn = db.connect().unwrap();
let mut results = conn.query("SELECT * FROM items", ()).await.unwrap();
let mut items: Vec<T> = Vec::new();
while let Some(row) = results.next().await.unwrap() {
let item: Item = Item {
task: row.get(0).unwrap(),
};
items.push(item);
}
Ok(HttpResponse::Ok().json(items))
}
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Turso + Actix Web Traffic Tracker" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-web-traffic-tracker-actix">
See the full source code
</Card>
</CardGroup>
# Turso + Axum
Source: https://docs.turso.tech/sdk/rust/guides/axum
Set up Turso in your Axum project in minutes
![Axum banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/axum-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an Axum app — [learn more](https://github.com/tokio-rs/axum)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Add the libsql crate to the project">
```sh
cargo add libsql
```
<Note>
Optionally, you can add a package such as [`dotenvy`](https://docs.rs/dotenvy/latest/dotenvy) to help you work with `.env` files:
```sh
cargo add dotenvy
```
</Note>
</Step>
<Step title="Execute SQL">
```rust
use libsql::{Builder, Connection, Database, Result};
#[tokio::main]
async fn main() -> Result<()> {
dotenv().ok();
let db_url = std::env::var("TURSO_DATABASE_URL").expect("TURSO_DATABASE_URL must be set");
let auth_token = std::env::var("TURSO_AUTH_TOKEN").expect("TURSO_AUTH_TOKEN must be set");
let db = Builder::new_remote(db_url, auth_token)
.build()
.await?;
let conn = db.connect()?;
// Execute a query
let mut rows = conn.query("SELECT * FROM users", ()).await?;
while let Some(row) = rows.next().await? {
let id: i64 = row.get(0)?;
let name: String = row.get(1)?;
println!("User: {} - {}", id, name);
}
Ok(())
}
```
</Step>
<Step title="Use in an Axum handler">
```rust
use axum::{
extract::State,
routing::get,
Json, Router,
};
use libsql::{Builder, Connection, Database};
use serde::Serialize;
#[derive(Clone)]
struct AppState {
db: Database,
}
#[derive(Serialize)]
struct User {
id: i64,
name: String,
}
async fn get_users(State(state): State<AppState>) -> Json<Vec<User>> {
let conn = state.db.connect().unwrap();
let mut rows = conn.query("SELECT id, name FROM users", ()).await.unwrap();
let mut users = Vec::new();
while let Some(row) = rows.next().await.unwrap() {
users.push(User {
id: row.get(0).unwrap(),
name: row.get(1).unwrap(),
});
}
Json(users)
}
#[tokio::main]
async fn main() {
let db_url = std::env::var("TURSO_DATABASE_URL").expect("TURSO_DATABASE_URL must be set");
let auth_token = std::env::var("TURSO_AUTH_TOKEN").expect("TURSO_AUTH_TOKEN must be set");
let db = Builder::new_remote(db_url, auth_token)
.build()
.await
.unwrap();
let app_state = AppState { db };
let app = Router::new()
.route("/users", get(get_users))
.with_state(app_state);
axum::Server::bind(&"0.0.0.0:3000".parse().unwrap())
.serve(app.into_make_service())
.await
.unwrap();
}
```
This example creates a shared `Database` instance in the application state, which is then used in the handler to execute queries.
</Step>
</Steps>
# Turso + Rocket
Source: https://docs.turso.tech/sdk/rust/guides/rocket
Set up Turso in your Rocket project in minutes
![Rocket banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/rocket-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Rocket app — [learn more](https://rocket.rs/v0.5/guide/getting-started/)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Add the libsql crate to the project">
```sh
cargo add libsql
```
<Note>
Optionally, you can add a package such as [`dotenvy`](https://docs.rs/dotenvy/latest/dotenvy) to help you work with `.env` files:
```sh
cargo add dotenvy
```
</Note>
</Step>
<Step title="Execute SQL">
```rust
#[get("/todos")]
async fn get_todos() -> Json<Vec<Todo>> {
dotenv().expect(".env file not found");
let url = env::var("TURSO_DATABASE_URL").expect("TURSO_DATABASE_URL not found!");
let token = env::var("TURSO_AUTH_TOKEN").expect("TURSO_AUTH_TOKEN not found!");
let db = Database::open_remote(url, token).unwrap();
let conn = db.connect().unwrap();
let mut response = conn.query("select * from todos", ()).await.unwrap();
let mut todos: Vec<Todo> = Vec::new();
while let Some(row) = response.next().unwrap() {
let todo: Todo = Todo {
task: row.get(0).unwrap(),
};
todos.push(todo);
}
Json(todos)
}
#[launch]
fn rocket() -> _ {
dotenv().ok();
rocket::build().mount("/", routes![get_todos])
}
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Turso + Rocket Todo List" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-todo-rocket">
See the full source code
</Card>
</CardGroup>
# Tauri + Turso
Source: https://docs.turso.tech/sdk/rust/guides/tauri
Set up Turso in your Tauri project in minutes
![Tauri banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/tauri-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Tauri app — [learn more](https://tauri.app/v1/guides/getting-started/setup)
<Steps>
<Step title="Add the following crates to the Tauri project's dependencies">
```toml src-tauri/Cargo.toml
[dependencies]
serde_json = "1.0"
serde = { version = "1.0", features = ["derive"] }
reqwest = { version = "0.11.22", features = ["json", "blocking"] }
dotenvy = "0.15.7"
tokio = { version = "1", features = ["full"] }
libsql = { git = "https://github.com/tursodatabase/libsql" }
tracing-subscriber = "0.3"
tracing = "0.1.40"
[patch.crates-io]
sqlite3-parser = { git = "https://github.com/LucioFranco/lemon-rs" }
```
</Step>
<Step title="Fetch Rust dependencies inside the `src-tauri` directory.">
```bash
cargo fetch
```
</Step>
<Step title="Configure database credentials">
Get the database URL.
```bash
turso db show --url <database-name>
```
Get the database authentication token.
```bash
turso db tokens create <database-name>
```
Assign acquired credentials to the environment variables inside `src-tauri/.env`.
```bash src-tauri/.env
TURSO_SYNC_URL="..."
TURSO_AUTH_TOKEN="..."
DB_PATH=./my-data.db # embedded replica
```
</Step>
<Step title="Execute SQL">
```rust src-tauri/src/main.rs
use dotenvy::dotenv;
use libsql::{params, Database};
use serde::{Deserialize, Serialize};
use std::env;
use tracing::info;
#[derive(Serialize, Debug)]
struct Error {
msg: String,
}
type Result<T> = std::result::Result<T, Error>;
impl<T> From<T> for Error
where
T: std::error::Error,
{
fn from(value: T) -> Self {
Self {
msg: value.to_string(),
}
}
}
#[derive(Deserialize, Serialize, Debug)]
pub struct Item {
id: String,
foo: String,
bar: String,
}
#[tauri::command]
async fn get_all_items() -> Result<Vec<Item>> {
dotenv().expect(".env file not found");
let db_path = env::var("DB_PATH").unwrap();
let sync_url = env::var("TURSO_SYNC_URL").unwrap();
let auth_token = env::var("TURSO_AUTH_TOKEN").unwrap();
let db = Database::open_with_remote_sync(db_path, sync_url, auth_token).await?;
let conn = db.connect()?;
let mut results = conn
.query("SELECT * FROM table_name", ())
.await?;
let mut items: Vec<Item> = Vec::new();
while let Some(row) = results.next()? {
let note: Item = Item {
id: row.get(0)?,
foo: row.get(1)?,
bar: row.get(2)?,
};
items.push(item);
}
Ok(items)
}
fn main() {
tracing_subscriber::fmt::init();
tauri::Builder::default()
.invoke_handler(tauri::generate_handler![
get_all_items,
])
.run(tauri::generate_context!())
.expect("error while running tauri application");
}
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Personal Notes App" icon="github" href="https://github.com/turso-extended/app-turso-notes/tree/master">
See the full source code
</Card>
</CardGroup>
# Turso Quickstart (Rust)
Source: https://docs.turso.tech/sdk/rust/quickstart
Get started with Turso and Rust using the libSQL crate in a few simple steps
In this Rust quickstart we will learn how to:
* Retrieve database credentials
* Install the Rust libSQL crate
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install">
First begin by installing the `libsql` [crate](https://crates.io/crates/libsql):
```bash
cargo add libsql
```
</Step>
<Step title="Connect">
You must first create a `Database` object and then open a `Connection` to it:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```rust
use libsql::Builder;
let url = std::env::var("TURSO_DATABASE_URL").expect("TURSO_DATABASE_URL must be set");
let token = std::env::var("TURSO_AUTH_TOKEN").expect("TURSO_AUTH_TOKEN must be set");
let db = Builder::new_remote_replica("local.db", url, token)
.build()
.await?;
let conn = db.connect()?;
```
</Accordion>
<Accordion title="Local only">
```rust
use libsql::Builder;
let db = Builder::new_local("local.db").build().await?;
let conn = db.connect()?;
```
</Accordion>
<Accordion title="Remote only">
```rust
use libsql::Builder;
let url = std::env::var("TURSO_DATABASE_URL").expect("TURSO_DATABASE_URL must be set");
let token = std::env::var("TURSO_AUTH_TOKEN").expect("TURSO_AUTH_TOKEN must be set");
let db = Builder::new_remote(url, token)
.build()
.await?;
let conn = db.connect()?;
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database by calling `execute()`:
```rust
conn.execute("SELECT * FROM users", ()).await?;
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```rust Positional
conn.execute("SELECT * FROM users WHERE id = ?1", libsql::params![1]).await?;
```
```rust Named
conn.execute("INSERT INTO users (name) VALUES (:name)", libsql::named_params! { ":name": "Iku" }).await?;
```
</CodeGroup>
To retrieve results from a query, you can use the `query()` method:
```rust
let mut rows = conn.query("SELECT * FROM users", ()).await?;
while let Some(row) = rows.next().await? {
let id: i64 = row.get(0)?;
let name: String = row.get(1)?;
println!("User: {} - {}", id, name);
}
```
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the database type to sync your local database with the primary database:
```rust
db.sync().await.unwrap();
```
You can also set up automatic periodic syncing when creating the database:
```rust
use std::time::Duration;
let db = Builder::new_remote_replica("local.db", url, token)
.sync_interval(Duration::from_secs(60))
.build()
.await?;
```
This will automatically sync the database every 60 seconds.
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/rust/reference
libSQL Rust Reference
The libSQL Rust crate contains everything you need to work with Turso and works flawlessly with popular async runtimes like `tokio`.
## Installing
Install the crate in your project using the following command:
```bash
cargo add libsql
```
### Conditional compilation
The libsql rust client supports [conditionally compiling](https://doc.rust-lang.org/cargo/reference/features.html#dependency-features) certain features to reduce compile times depending on what features you would like to use.
The following features are available:
| Feature       | Description                                                                                                                                                                                                                                          |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `remote`      | Enables the HTTP-only client, allowing communication with a remote sqld server using pure Rust. Does not require compiling C code for SQLite. Suitable for projects that only need to interact with a remote database.                               |
| `core`        | Enables the local database only, incorporating the C SQLite3 code into the build. This is the foundation for local database operations but does not include additional features like replication or encryption.                                      |
| `replication` | Combines core with additional code required for replication, enabling the embedded replica features.                                                                                                                                                 |
| `encryption`  | Enables encryption at rest support, adding the necessary code to compile encryption capabilities and expose functions for configuring it. **This is optional and not enabled by default**, catering to projects that require enhanced data security. |
```toml
[dependencies]
libsql = { version = "...", features = ["encryption"] }
```
<Note>
Using `core` and `replication` features require a c compiler. The `encryption` feature requires `cmake` to be installed on your system.
</Note>
## Initializing
Make sure add the crate to your project at the top of your file:
```rust
use libsql::Builder;
let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();
let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();
let conn = db.connect().unwrap();
```
## In-Memory Databases
libSQL supports connecting to [in-memory databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't require persistence:
```rust
use libsql::Builder;
let db = Builder::new_local(":memory:").build().await.unwrap();
let conn = db.connect().unwrap();
```
## Local Development
You can work locally using an SQLite file using `new_local`:
```rust
use libsql::Builder;
let mut db = Builder::new_local("local.db").build().await.unwrap();
let conn = db.connect().unwrap();
```
## Embedded Replicas
You can work with embedded replicas using `new_remote_replica` that can sync from the remote URL and delegate writes to the remote primary database:
```rust
use libsql::Builder;
let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();
let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();
let conn = db.connect().unwrap();
```
### Manual Sync
The `sync` function allows you to sync manually the local database with the remote counterpart:
```rust
use libsql::Builder;
let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();
let mut db = Builder::new_remote_replica("local.db", &url, &token).build().await.unwrap();
let conn = db.connect().unwrap();
db.sync().await.unwrap(); // Call sync manually to update local database
```
<Info>
If you require full control over how frames get from your instance of `sqld` (libSQL Server), you can do this using `new_local_replica` and `sync_frames`. Reach out to us [on Discord](https://discord.gg/turso) if you want to learn more.
</Info>
### Sync Interval
The `sync_interval` function allows you to set an interval for automatic synchronization of the database in the background:
```rust
use libsql::Builder;
use std::time::Duration;
let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();
let mut db = Builder::new_remote_replica("local.db", &url, &token)
.sync_interval(Duration::from_secs(300)) // Sync every 5 minutes
.build()
.await.unwrap();
let conn = db.connect().unwrap();
```
### Read Your Own Writes
The `read_your_writes` function configures the database connection to ensure that writes are immediately visible to subsequent read operations initiated by the same connection. This is **enabled by default**, and is particularly important in distributed systems to ensure consistency from the perspective of the writing process.
You can disable this behavior by passing `false` to the function:
```rust
use libsql::Builder;
let url = env::var("LIBSQL_URL").expect("LIBSQL_URL must be set");
let token = env::var("LIBSQL_AUTH_TOKEN").unwrap_or_default();
let mut db = Builder::new_remote_replica("local.db", &url, &token)
.read_your_writes(false) // Disable reading your own writes
.build()
.await.unwrap();
let conn = db.connect().unwrap();
```
## Encryption
To enable encryption on a SQLite file (`new_local` or `new_remote_replica`), make sure you have the [`encryption` feature enabled](#conditional-compilation), and pass the `encryption_config`:
<Snippet file="encryption-at-rest-rust.mdx" />
<Info>
Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations — [learn more](/libsql#encryption-at-rest).
</Info>
## Simple query
You can pass a string to `execute()` to invoke a SQL statement, as well as optional arguments:
<CodeGroup>
```rust Query
conn.execute("SELECT * FROM users", ()).await?;
```
```rust Arguments
conn.execute("SELECT * FROM users WHERE id = ?1", [1]).await?;
```
</CodeGroup>
## Prepared Statements
You can prepare a cached statement using `prepare()` and then execute it with `query()`:
```rust
let stmt = db_conn.prepare("SELECT * FROM users").await?;
db_conn.query(&stmt, [&1]).await?;
```
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```rust Positional
conn.execute("SELECT * FROM users WHERE id = ?1", params![1]).await?;
```
```rust Named
conn.execute("INSERT INTO users (name) VALUES (:name)", libsql::named_params! { ":name": "Iku" }).await?;
```
</CodeGroup>
## Deserialization
You can use the `de::from_row` function to deserialize a row into a struct:
```rust
use libsql::{de, Builder};
let mut stmt = conn
.prepare("SELECT * FROM users WHERE id = ?1")
.await
.unwrap();
let row = stmt
.query([1])
.await
.unwrap()
.next()
.await
.unwrap()
.unwrap();
#[derive(Debug, serde::Deserialize)]
struct User {
name: String,
age: i64,
vision: f64,
avatar: Vec<u8>,
}
let user = de::from_row::<User>(&row).unwrap();
```
## Batch Transactions
A batch consists of multiple SQL statements executed sequentially within an implicit transaction. The backend handles the transaction: success commits all changes, while any failure results in a full rollback with no modifications.
```rust
conn.execute_batch(r#"
CREATE TABLE IF NOT EXISTS users (
id INTEGER PRIMARY KEY,
name TEXT NOT NULL
);
INSERT INTO users (name) VALUES ('Alice');
INSERT INTO users (name) VALUES ('Bob');
"#).await?;
```
## Interactive Transactions
Interactive transactions in SQLite ensure the consistency of a series of read and write operations within a transaction's scope. These transactions give you control over when to commit or roll back changes, isolating them from other client activity.
* `transaction()` — with default transaction behavior (`DEFFERED`)
* `transaction_with_behavior()` — with custom transaction behavior
<CodeGroup>
```rust Default
let mut tx = db_conn.transaction().await?;
tx.execute("INSERT INTO users (name) VALUES (?1)", ["Iku"]).await?;
tx.execute("INSERT INTO users (name) VALUES (?1)", ["Iku 2"]).await?;
tx.commit().await?;
```
```rust Advanced control
let mut tx = db_conn.transaction_with_behavior(TransactionBehavior::Immediate).await?;
tx.execute("UPDATE users SET age = age + 1 WHERE id = ?1", [1]).await?;
tx.execute("DELETE FROM users WHERE id = ?1", [2]).await?;
if operations_successful {
tx.commit().await?;
} else {
tx.rollback().await?;
}
```
</CodeGroup>
# Turso Quickstart (Swift)
Source: https://docs.turso.tech/sdk/swift/quickstart
Get started with Turso and Swift using the libSQL client in a few simple steps.
<Snippet file="technical-preview-banner.mdx" />
In this Swift quickstart we will learn how to:
* Retrieve database credentials
* Install the libSQL package
* Connect to a local or remote Turso database
* Execute a query using SQL
* Sync changes to local database (optional)
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Snippet file="mobile-secrets-warning.mdx" />
</Step>
<Step title="Install">
First begin by adding `libsql` as a package dependency in XCode using this repo:
<Card title="libSQL Swift" href="https://github.com/tursodatabase/libsql-swift">
Build from source code
</Card>
Or add it to your SwiftPM dependencies:
```swift
import PackageDescription
let package = Package(
// ...
dependencies: [
.package(url: "https://github.com/tursodatabase/libsql-swift", from: "0.1.1"),
],
// ...
)
```
</Step>
<Step title="Connect">
You must first create a `Database` object and then open a `Connection` to it:
<AccordionGroup>
<Accordion title="Embedded Replicas">
```swift
import Libsql
let db = try Database(
path: "./local.db",
url: "TURSO_DATABASE_URL",
authToken: "TURSO_AUTH_TOKEN",
syncInterval: 300
)
let conn = try db.connect()
```
</Accordion>
<Accordion title="Local only">
```swift
import Libsql
let db = try Database(
path: "./local.db",
)
let conn = try db.connect()
```
</Accordion>
<Accordion title="Remote only">
```swift
import Libsql
let db = try Database(
url: "TURSO_DATABASE_URL",
authToken: "TURSO_AUTH_TOKEN"
)
let conn = try db.connect()
```
</Accordion>
</AccordionGroup>
</Step>
<Step title="Execute">
You can execute a SQL query against your existing database by calling `query()`,
or `execute()` when you expect the query to not yield any rows:
```swift
let rows = try conn.query("SELECT * FROM users")
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```swift Positional Query
try conn.query("SELECT * FROM users WHERE id = ?", 1)
```
```swift Positional Insert
try conn.execute("INSERT INTO users (id) VALUES (?)", 1)
```
<Note>Named arguments are not supported yet.</Note>
</CodeGroup>
</Step>
<Step title="Sync (Embedded Replicas only)">
When using embedded replicas you should call `sync()` on the database type to
sync your local database with the primary database, unless you are using
`sync_interval` (though there is no issue with calling `sync` with
`sync_interval` enabled):
```swift
try db.sync()
```
</Step>
</Steps>
# Swift Reference
Source: https://docs.turso.tech/sdk/swift/reference
libSQL Swift Reference
<Snippet file="technical-preview-banner.mdx" />
## Installing
First begin by adding `libsql` as a package dependency in XCode using this repo:
<Card title="libSQL Swift" href="https://github.com/tursodatabase/libsql-swift">
Build from source code
</Card>
Or add it to your SwiftPM dependencies:
```swift
import PackageDescription
let package = Package(
// ...
dependencies: [
.package(url: "https://github.com/tursodatabase/libsql-swift", from: "0.1.1"),
],
// ...
)
```
## In-Memory Databases
libSQL supports connecting to [in-memory
databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't
require persistence:
```swift
import Libsql
let db = Database(":memory:")
let conn = try db.connect()
```
## Local Development
You can work locally using an SQLite file:
```swift
import Libsql
let db = Database("local.db")
let conn = try db.connect()
```
## Embedded Replicas
You can work with embedded replicas that can sync from the remote URL and
delegate writes to the remote primary database:
```swift
import Libsql
let db = try Database(
path: "./local.db",
url: "TURSO_DATABASE_URL",
authToken: "TURSO_AUTH_TOKEN"
)
let conn = try db.connect()
```
### Manual Sync
The `sync` function allows you to sync manually the local database with the remote counterpart:
```swift
try db.sync() // Call sync manually to update local database
```
### Sync Interval
The `syncInterval` parameter allows you to set an interval for automatic
synchronization of the database in the background:
```swift
import Libsql
let db = try Database(
path: "./local.db",
url: "TURSO_DATABASE_URL",
authToken: "TURSO_AUTH_TOKEN"
syncInterval: 300 // Sync every 3 seconds
)
let conn = try db.connect()
```
### Read Your Own Writes
The `readYourWrites` parameter configures the database connection to ensure
that writes are immediately visible to subsequent read operations initiated by
the same connection. This is **enabled by default**, and is particularly
important in distributed systems to ensure consistency from the perspective of
the writing process.
You can disable this behavior by passing `false` to the function:
```swift
import Libsql
let db = try Database(
path: "./local.db",
url: <LIBSQL_URL>,
authToken: <LIBSQL_AUTH_TOKEN>,
readYourWrites: false
)
let conn = try db.connect()
```
## Simple query
You can pass a string to `query()` to invoke a SQL statement, as well as
optional arguments:
<CodeGroup>
```swift Execute
try conn.execute("INSERT INTO users VALUES (?)", [1])
```
```swift Query
try conn.query("SELECT * FROM users")
```
```swift Arguments
try conn.query("SELECT * FROM users WHERE id = ?", [1])
```
</CodeGroup>
## Prepared Statements
You can prepare a cached statement using `prepare()` and then execute it with
`query()`:
```swift
let stmt = try conn.prepare("SELECT * FROM users WHERE id = ?")
stmt.bind([1])
stmt.query()
```
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```swift Positional
try conn.query("SELECT * FROM users WHERE id = ?", [1])
```
```swift Named
try conn.query("SELECT * FROM users WHERE id = :id", [ ":id": 1 ])
```
</CodeGroup>
# Examples
Source: https://docs.turso.tech/sdk/ts/examples
# Astro + Turso
Source: https://docs.turso.tech/sdk/ts/guides/astro
Set up Turso in your Astro project in minutes.
![Astro banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/astro-banner.png)
## Prerequisites
To get the most out of this guide, you'll need to:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an Astro project — [learn more](https://docs.astro.build/en/install/auto/#1-run-the-setup-wizard)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL client">
```ts src/turso.ts
import { createClient } from "@libsql/client/web";
export const turso = createClient({
url: import.meta.env.TURSO_DATABASE_URL!,
authToken: import.meta.env.TURSO_AUTH_TOKEN,
});
```
<Note>
Astro will soon introduce a new ENV API. [Take a
look](https://docs.astro.build/en/reference/configuration-reference/#experimentalenv).
</Note>
</Step>
<Step title="Execute SQL">
```ts
---
import { turso } from './turso'
const { rows } = await turso.execute('SELECT * FROM table_name')
---
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Blog" icon="github" href="https://github.com/turso-extended/app-tustro-blog">
See the full source code
</Card>
</CardGroup>
# Elysia + Turso
Source: https://docs.turso.tech/sdk/ts/guides/elysia
Set up Turso in your Elysia project in minutes.
![Elysia banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/elysia-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have an Elysia app — [learn more](https://elysiajs.com/quick-start.html)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL client">
<Snippet file="configure-libsql-client-ts.mdx" />
</Step>
<Step title="Execute SQL">
```ts
import { Elysia } from "elysia";
import { turso } from "./lib/turso";
const app = new Elysia().get("/items", async () => {
const { rows } = await turso.execute("SELECT * FROM items");
return rows;
});
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Expenses tracker app with Elysia & Turso" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-expenses-tracker-elysia">
See the full source code
</Card>
</CardGroup>
# Hono + Turso
Source: https://docs.turso.tech/sdk/ts/guides/hono
Set up Turso in your Hono project in minutes.
![Hono banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/hono-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Hono app — [learn more](https://hono.dev/top#quick-start)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL client">
<Snippet file="configure-libsql-client-ts.mdx" />
</Step>
<Step title="Execute SQL">
```ts
import { Hono } from "hono";
import { turso } from "./lib/turso";
const app = new Hono();
app.get("/items", async (c) => {
const { rows } = await turso.execute("SELECT * FROM items");
return c.json({ rows });
});
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Expenses tracker app with Hono & Turso" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-expenses-tracker-hono">
See the full source code
</Card>
</CardGroup>
# Next.js + Turso
Source: https://docs.turso.tech/sdk/ts/guides/nextjs
Set up Turso in your Next.js project in minutes.
![Next.js banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/nextjs-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Next.js app — [learn more](https://nextjs.org/docs/getting-started/installation)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL client">
<Snippet file="configure-libsql-client-ts.mdx" />
</Step>
<Step title="Execute SQL">
<CodeGroup>
```tsx App Router
import { turso } from "@/lib/turso";
export default async function Page() {
const { rows } = await turso.execute("SELECT * FROM table_name");
return (
<ul>
{rows.map((row) => (
<li key={row.id}>{row.id}</li>
))}
</ul>
);
}
```
```ts Pages Directory
import type { InferGetServerSidePropsType, GetServerSideProps } from "next";
import { turso } from "@/lib/turso";
export const getServerSideProps = (async () => {
const { rows } = await turso.execute("SELECT * FROM table_name");
return {
props: {
rows,
},
};
}) satisfies GetServerSideProps<{ rows: any[] }>;
export default function Page({
rows,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
return (
<ul>
{rows.map((row) => (
<li key={row.id}>{row.id}</li>
))}
</ul>
);
}
```
</CodeGroup>
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Full Stack App" icon="github" href="https://github.com/turso-extended/app-turso-nextjs-starter">
See the full source code
</Card>
</CardGroup>
# Nuxt + Turso
Source: https://docs.turso.tech/sdk/ts/guides/nuxt
Set up Turso in your Nuxt project in minutes
![Nuxt banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/nuxt-banner.png)
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Nuxt app — [learn more](https://nuxt.com/docs/getting-started/installation#new-project)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
Get the database URL:
```bash
turso db show --url <database-name>
```
Get the database authentication token:
```bash
turso db tokens create <database-name>
```
Assign credentials to the environment variables inside `.env`.
```bash
NUXT_TURSO_DATABASE_URL=
NUXT_TURSO_AUTH_TOKEN=
```
</Step>
<Step title="Configure variables inside Nuxt's runtime config.">
```ts nuxt.config.ts
export default defineNuxtConfig({
runtimeConfig: {
turso: {
databaseUrl: "",
authToken: "",
},
},
});
```
<Note>
Make sure that names of the keys in the `runtimeConfig` object match the names
of your environment variables. Read more about this
[here](https://nuxt.com/docs/guide/going-further/runtime-config).
</Note>
</Step>
<Step title="Configure libSQL Client.">
```ts server/utils/turso.ts
import { createClient } from "@libsql/client";
// You can optionally pass in the event to useRuntimeConfig
// import { H3Event } from "h3";
export function useTurso(/* event: H3Event */) {
const { turso } = useRuntimeConfig(/* event */);
return createClient({
url: turso.databaseUrl,
authToken: turso.authToken,
});
}
```
</Step>
<Step title="Execute SQL">
```ts server/api/items.get.ts
export default defineEventHandler(async (event) => {
const client = useTurso(/* event */);
const { rows } = await client.execute("select * from table_name");
return {
data: {
items: rows,
},
};
});
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Website + App" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-top-web-frameworks">
See the full source code
</Card>
</CardGroup>
# Quasar + Turso
Source: https://docs.turso.tech/sdk/ts/guides/quasar
Set up Turso in your Quasar project in minutes
![Quasar banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/quasar-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Quasar app — [learn more](https://quasar.dev/start/quick-start#step-1-create-a-project)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
Get the database URL:
```bash
turso db show --url <database-name>
```
Get the database authentication token:
```bash
turso db tokens create <database-name>
```
Assign credentials to the environment variables inside `.env.local`.
```bash
VITE_TURSO_DATABASE_URL="..."
VITE_TURSO_AUTH_TOKEN="..."
```
</Step>
<Step title="Configure libSQL Client">
```js
import { createClient } from "@libsql/client/web";
const turso = createClient({
url: import.meta.env.VITE_TURSO_DATABASE_URL,
authToken: import.meta.env.VITE_TURSO_AUTH_TOKEN,
});
```
<Info>
Avoid a [gotcha
moment](https://github.com/quasarframework/quasar/discussions/16071) by
modifying the app configuration using the settings below.
</Info>
```javascript quasar.config.js
{
build: {
target: {
browser: [
'es2020', 'edge88', 'firefox78', 'chrome87', 'safari13.1'
],
node: 'node16'
},
extendViteConf(config) {
config.optimizeDeps = {
esbuildOptions: {
target: 'es2020',
}
}
}
}
}
```
</Step>
<Step title="Fetch data from Turso.">
```js IndexPage.vue
import { ref } from "vue";
const items = ref();
const { rows } = await turso.execute("select * from my-table");
items.value = rows;
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Todo App" icon="github" href="https://github.com/tursodatabase/examples/tree/master/quasar-todo-list">
See the full source code
</Card>
</CardGroup>
# Qwik + Turso
Source: https://docs.turso.tech/sdk/ts/guides/qwik
Set up Turso in your Qwik project in minutes
![Qwik banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/qwik-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Qwik app — [learn more](https://qwik.builder.io/docs/getting-started/#create-an-app-using-the-cli)
<Steps>
<Step title="Add Turso Integration">
<CodeGroup>
```bash npm
npm run qwik add turso
```
```bash pnpm
pnpm qwik add turso
```
```bash yarn
yarn qwik add turso
```
</CodeGroup>
</Step>
<Step title="Configure database credentials">
Get the database URL:
```bash
turso db show --url <database-name>
```
Get the database authentication token:
```bash
turso db tokens create <database-name>
```
Assign credentials to the environment variables inside `.env.local`.
```bash
PRIVATE_TURSO_DATABASE_URL="..."
PRIVATE_TURSO_AUTH_TOKEN="..."
```
</Step>
<Step title="Execute SQL">
```ts
import { tursoClient } from "~/utils/turso";
export const useFrameworks = routeLoader$(
async (requestEvent: RequestEventBase) => {
const db = tursoClient(requestEvent["env"]);
const { rows } = await db.execute("select * from table_name");
return {
items: rows,
};
}
);
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Social Website" icon="github" href="https://github.com/turso-extended/app-find-me-on">
See the full source code
</Card>
<Card title="Shopping Cart" icon="github" href="https://github.com/turso-extended/app-turqw-store">
See the full source code
</Card>
</CardGroup>
# Remix + Turso
Source: https://docs.turso.tech/sdk/ts/guides/remix
Set up Turso in your Remix project in minutes
![Remix banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/remix-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a Remix app — [learn more](https://remix.run/docs/en/main/start/quickstart#quick-start)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL Client.">
<Snippet file="configure-libsql-client-ts.mdx" />
</Step>
<Step title="Execute SQL">
```ts app/routes/_index.ts
import type { LoaderFunction } from "@remix-run/node";
import { turso } from "~/lib/turso";
export const loader: LoaderFunction = async () => {
const { rows } = await turso.execute("SELECT * from TABLE_NAME");
return {
items: rows,
};
};
```
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="E-commerce Store" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-the-mug-store">
See the full source code
</Card>
<Card title="CRM App" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-turso-crm">
See the full source code
</Card>
</CardGroup>
# SvelteKit + Turso
Source: https://docs.turso.tech/sdk/ts/guides/sveltekit
Set up Turso in your SvelteKit project in minutes
![SvelteKit banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/svelte-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Have a SvelteKit app — [learn more](https://kit.svelte.dev/docs/creating-a-project)
<Steps>
<Step title="Install the libSQL SDK">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Configure database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Configure libSQL Client.">
<CodeGroup>
```ts Node.js / Serverless
import { TURSO_DATABASE_URL, TURSO_AUTH_TOKEN } from "$env/static/private";
import { createClient } from "@libsql/client";
export const turso = createClient({
url: TURSO_DATABASE_URL,
authToken: TURSO_AUTH_TOKEN,
});
```
```ts Edge Runtimes
import { TURSO_DATABASE_URL, TURSO_AUTH_TOKEN } from "$env/static/private";
import { createClient } from "@libsql/client/web";
export const turso = createClient({
url: TURSO_DATABASE_URL,
authToken: TURSO_AUTH_TOKEN,
});
```
</CodeGroup>
</Step>
<Step title="Execute SQL">
<CodeGroup>
```ts src/routes/+page.server.ts
import { turso } from "$lib/turso.server";
export async function load() {
const { rows } = await turso.execute("SELECT * FROM table_name");
return { rows };
}
```
```svelte src/routes/+page.svelte
<script lang="ts">
export let data
</script>
<ul>
{#each data.rows as row}
<li>{row.id}</li>
{/each}
</ul>
```
</CodeGroup>
</Step>
</Steps>
## Examples
<CardGroup cols={2}>
<Card title="Blog" icon="github" href="https://github.com/tursodatabase/examples/tree/master/app-at-the-polls">
See the full source code
</Card>
</CardGroup>
# Sentry
Source: https://docs.turso.tech/sdk/ts/integrations/sentry
Trace slow queries and capture SQL errors with Sentry.
The [Sentry](https://sentry.io/integrations/turso) integration for `@libsql/client` provides tracing, breadcrumbs, and error handling for SQL queries.
<Snippet file="technical-preview-banner.mdx" />
## Install
```bash
npm install sentry-integration-libsql-client
```
## Quickstart
Once you have a `@libsql/client` instance, you can integrate it with Sentry like this:
```ts
import * as Sentry from "@sentry/node";
import { createClient } from "@libsql/client";
import { libsqlIntegration } from "sentry-integration-libsql-client";
const libsqlClient = createClient({
url: "libsql://...",
authToken: "...",
});
Sentry.init({
dsn: "...",
integrations: [libsqlIntegration(libsqlClient, Sentry)],
});
await libsqlClient.execute("SELECT * FROM users");
```
## Options
By default, everything is turned on. You can configure what you want by passing a third argument to the `libsqlIntegration` function.
| Option        | Default | Description                            |
| ------------- | ------- | -------------------------------------- |
| `tracing`     | `true`  | Enable tracing for SQL queries.        |
| `breadcrumbs` | `true`  | Enable breadcrumbs for SQL queries.    |
| `errors`      | `true`  | Enable error handling for SQL queries. |
```ts
Sentry.init({
dsn: "...",
integrations: [
libsqlIntegration(libsqlClient, Sentry, {
tracing: false,
breadcrumbs: false,
errors: false,
}),
],
});
```
# Drizzle + Turso
Source: https://docs.turso.tech/sdk/ts/orm/drizzle
Configure Drizzle to work with Turso
![Drizzle banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/drizzle-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
<Steps>
<Step title="Install Drizzle and the libSQL SDK">
<CodeGroup>
```bash npm
npm i drizzle-orm @libsql/client dotenv
npm i -D drizzle-kit
```
```bash pnpm
pnpm add drizzle-orm @libsql/client dotenv
pnpm add -D drizzle-kit
```
```bash yarn
yarn add drizzle-orm @libsql/client dotenv
yarn add -D drizzle-kit
```
</CodeGroup>
Finish by updating `package.json` to include three new `scripts`:
```json
{
"scripts": {
"db:generate": "drizzle-kit generate",
"db:migrate": "drizzle-kit migrate",
"db:studio": "drizzle-kit studio"
}
}
```
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Create a Drizzle schema">
```ts db/schema.ts
import { sql } from "drizzle-orm";
import { text, sqliteTable } from "drizzle-orm/sqlite-core";
export const fooTable = sqliteTable("foo", {
bar: text("bar").notNull().default("Hey!"),
});
```
</Step>
<Step title="Configure Drizzle Kit">
Create the file `drizzle.config.ts` in the root of your project with the following:
```ts drizzle.config.ts
require("dotenv").config();
import type { Config } from "drizzle-kit";
export default {
schema: "./db/schema.ts",
out: "./migrations",
dialect: "turso",
dbCredentials: {
url: process.env.TURSO_DATABASE_URL!,
authToken: process.env.TURSO_AUTH_TOKEN,
},
} satisfies Config;
```
<Note>
We're using `dotenv` above, but if you're using something like Next.js, Remix, Astro, or Vite, you can use their built-in environment variables manager to source these values.
</Note>
</Step>
<Step title="Connect Drizzle with libSQL">
<CodeGroup>
```ts Node.js / Serverless
import { drizzle } from "drizzle-orm/libsql";
import { createClient } from "@libsql/client";
const turso = createClient({
url: process.env.TURSO_DATABASE_URL!,
authToken: process.env.TURSO_AUTH_TOKEN,
});
export const db = drizzle(turso);
```
```ts Edge Runtimes
import { drizzle } from "drizzle-orm/libsql";
import { createClient } from "@libsql/client/web";
const turso = createClient({
url: process.env.TURSO_DATABASE_URL!,
authToken: process.env.TURSO_AUTH_TOKEN,
});
export const db = drizzle(turso);
```
</CodeGroup>
</Step>
<Step title="Database migrations">
Drizzle can generate and apply database migrations with `drizzle-kit`.
Whenever you make changes to the schema, run `db:generate`:
```bash
npm run db:generate
```
Now apply these changes to the database with `db:migrate`:
```bash
npm run db:migrate
```
</Step>
<Step title="Query">
```ts
import { db } from "./db";
import { fooTable } from "./schema";
const result = await db.select().from(fooTable).all();
```
</Step>
<Step title="Connect Drizzle Studio">
<CodeGroup>
```bash npm
npm run db:studio
```
```bash pnpm
pnpm run db:studio
```
</CodeGroup>
</Step>
</Steps>
## Vector Embeddings
You can extend Drizzle to support Turso's native vector — [learn more](/features/ai-and-embeddings).
<Steps>
<Step title="Define custom vector type">
Inside `db/schema.ts`, add the following:
```typescript
import { sql } from "drizzle-orm";
import { customType } from "drizzle-orm/sqlite-core";
const float32Array = customType<{
data: number[];
config: { dimensions: number };
configRequired: true;
driverData: Buffer;
}>({
dataType(config) {
return `F32_BLOB(${config.dimensions})`;
},
fromDriver(value: Buffer) {
return Array.from(new Float32Array(value.buffer));
},
toDriver(value: number[]) {
return sql`vector32(${JSON.stringify(value)})`;
},
});
```
</Step>
<Step title="Create a table with a vector column">
Now where you define the schema, invoke `float32Array` to create a column that stores vectors:
```typescript
import { sqliteTable, integer } from "drizzle-orm/sqlite-core";
export const vectorTable = sqliteTable("vector_table", {
id: integer("id").primaryKey(),
vector: float32Array("vector", { dimensions: 3 }),
});
```
</Step>
<Step title="Create a vector index">
You will need to use raw SQL to create the index:
```typescript
import { drizzle } from "drizzle-orm/libsql";
import { createClient } from "@libsql/client";
const client = createClient({
url: process.env.TURSO_DATABASE_URL!,
authToken: process.env.TURSO_AUTH_TOKEN,
});
const db = drizzle(client);
await db.run(sql`
CREATE INDEX IF NOT EXISTS vector_index
ON vector_table(vector)
USING vector_cosine(3)
`);
```
</Step>
<Step title="Insert vector data">
```typescript
await db
.insert(vectorTable)
.values([{ vector: sql`vector32(${JSON.stringify([1.1, 2.2, 3.3])})` }]);
```
</Step>
<Step title="Query vector data">
Calculate vector distance:
```typescript
const res = await db
.select({
distance: sql<number>`vector_distance_cos(${vectorTable.vector}, vector32(${JSON.stringify([2.2, 3.3, 4.4])}))`,
})
.from(vectorTable);
console.log(res);
```
Perform efficient nearest neighbor search:
```typescript
const topK = await db
.select({
id: sql`id`,
distance: sql`distance`,
})
.from(
sql`vector_top_k('vector_index', vector32(${JSON.stringify([2.2, 3.3, 4.4])}), 5)`,
)
.leftJoin(vectorTable, sql`${vectorTable}.id = id`);
console.log(topK);
```
</Step>
</Steps>
Remember to create appropriate indexes for efficient vector operations and adjust vector dimensions as needed for your use case.
# Prisma + Turso
Source: https://docs.turso.tech/sdk/ts/orm/prisma
Configure Prisma to work with your Turso database
![Prisma banner](https://mintlify.s3.us-west-1.amazonaws.com/turso/images/guides/prisma-banner.png)
## Prerequisites
Before you start, make sure you:
* [Install the Turso CLI](/cli/installation)
* [Sign up or login to Turso](/cli/authentication#signup)
* Prisma versions 5.4.2 and later
<Steps>
<Step title="Install the libSQL SDK and its Prisma driver">
<CodeGroup>
```bash npm
npm install @libsql/client @prisma/adapter-libsql
```
```bash pnpm
pnpm add @libsql/client @prisma/adapter-libsql
```
```bash yarn
yarn add @libsql/client @prisma/adapter-libsql
```
</CodeGroup>
</Step>
<Step title="Retrieve database credentials">
<Snippet file="retrieve-database-credentials.mdx" />
</Step>
<Step title="Enable the `driverAdapters` preview feature flag:">
```js prisma/schema.prisma
generator client {
provider        = "prisma-client-js"
previewFeatures = ["driverAdapters"]
}
datasource db {
provider = "sqlite"
url      = "file:./dev.db"
}
```
</Step>
<Step title="Generate Prisma client">
<CodeGroup>
```sh npm
npx prisma generate
```
```sh pnpm
pnpm dlx prisma generate
```
</CodeGroup>
</Step>
<Step title="Update your Prisma Client Instance">
<CodeGroup>
```ts Node.js / Serverless
import { PrismaClient } from "@prisma/client";
import { PrismaLibSQL } from "@prisma/adapter-libsql";
import { createClient } from "@libsql/client";
const libsql = createClient({
url: process.env.TURSO_DATABASE_URL,
authToken: process.env.TURSO_AUTH_TOKEN,
});
const adapter = new PrismaLibSQL(libsql);
const prisma = new PrismaClient({ adapter });
```
```ts Edge Runtimes
import { PrismaClient } from "@prisma/client";
import { PrismaLibSQL } from "@prisma/adapter-libsql";
import { createClient } from "@libsql/client/web";
const libsql = createClient({
url: process.env.TURSO_DATABASE_URL,
authToken: process.env.TURSO_AUTH_TOKEN,
});
const adapter = new PrismaLibSQL(libsql);
const prisma = new PrismaClient({ adapter });
```
</CodeGroup>
</Step>
<Step title="Database Migrations">
Prisma Migrate and Introspection workflows are currently not supported when working with Turso — [learn more](https://www.prisma.io/docs/orm/overview/databases/turso#how-to-manage-schema-changes).
First, generate a migration file using prisma migrate dev against a local SQLite database
<CodeGroup>
```sh npm
npx prisma migrate dev --name init
```
```sh pnpm
pnpm dlx prisma migrate dev --name init
```
</CodeGroup>
Then, apply the migration to your Turso database using the Turso's CLI
```bash
turso db shell turso-prisma-db < ./prisma/migrations/20230922132717_init/migration.sql
```
<Info>
Replace `20230922132717_init` with the name of your migration created from the `npx prisma migrate dev` command.
</Info>
</Step>
<Step title="Query">
```ts
const response = await prisma.table_name.findMany();
```
</Step>
</Steps>
# Turso Quickstart (TypeScript / JS)
Source: https://docs.turso.tech/sdk/ts/quickstart
Get started with Turso and TypeScript using the libSQL client in a few simple steps
In this JavaScript quickstart we will learn how to:
* Retrieve database credentials
* Install the JavaScript libSQL client
* Connect to a remote Turso database
* Execute a query using SQL
<Steps>
<Step title="Retrieve database credentials">
You will need an existing database to continue. If you don't have one, [create one](/quickstart).
<Snippet file="retrieve-database-credentials.mdx" />
<Info>You will want to store these as environment variables.</Info>
</Step>
<Step title="Install @libsql/client">
<Snippet file="install-libsql-client-ts.mdx" />
</Step>
<Step title="Initialize a new client">
Next add your database URL and auth token:
<Snippet file="configure-libsql-client-ts.mdx" />
</Step>
<Step title="Execute a query using SQL">
You can execute a SQL query against your existing database by calling `execute()`:
```ts
await turso.execute("SELECT * FROM users");
```
If you need to use placeholders for values, you can do that:
<CodeGroup>
```ts Positional
await turso.execute({
sql: "SELECT * FROM users WHERE id = ?",
args: [1],
});
```
```ts Named
await turso.execute({
sql: "INSERT INTO users VALUES (:name)",
args: { name: "Iku" },
});
```
</CodeGroup>
</Step>
</Steps>
# Reference
Source: https://docs.turso.tech/sdk/ts/reference
libSQL JavaScript and TypeScript Reference
The following runtime environments are known to be compatible:
* Node.js version 12 or later
* Deno
* CloudFlare Workers
* Netlify & Vercel Edge Functions
<Info>
The JavaScript SDK comes with TypeScript bindings and supports environments where either language can be used. Both ESM and CJS modules are provided.
</Info>
## Installing
<Snippet file="install-libsql-client-ts.mdx" />
## Initializing
Import `createClient` to initialize a client that you can use to query your database:
<Snippet file="configure-libsql-client-ts.mdx" />
<br />
<Info>
If you're using libsql locally or an sqlite file, you can ignore passing `authToken`.
</Info>
## In-Memory Databases
libSQL supports connecting to [in-memory databases](https://www.sqlite.org/inmemorydb.html) for cases where you don't require persistence:
```ts {4}
import { createClient } from "@libsql/client";
const client = createClient({
url: ":memory:",
});
```
## Local Development
You can work locally using an SQLite file and passing the path to `createClient`:
```ts {4}
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:path/to/db-file.db",
authToken: "...",
});
```
<Warning>
The `@libsql/client/web` does not support local file URLs.
</Warning>
## Embedded Replicas
You can work with embedded replicas by passing your Turso Database URL to `syncUrl`:
```ts {5}
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:path/to/db-file.db",
syncUrl: "libsql://[databaseName]-[organizationSlug].turso.io",
authToken: "...",
});
```
<Snippet file="embedded-replicas-warning.mdx" />
### Manual Sync
The `sync()` function allows you to sync manually the local database with the remote counterpart:
```ts
await client.sync();
```
### Periodic Sync
You can automatically sync at intervals by configuring the `syncInterval` (seconds) property when instantiating a new libSQL client:
```ts {6}
import { createClient } from "@libsql/client";
const client = createClient({
url: "file:path/to/db-file.db",
syncUrl: "libsql://[databaseName]-[organizationSlug].turso.io",
syncInterval: 60,
authToken: "...",
});
```
## Encryption
To enable encryption on a SQLite file, pass the `encryptionKey`:
<Snippet file="encryption-at-rest-typescript.mdx" />
Encrypted databases appear as raw data and cannot be read as standard SQLite databases. You must use the libSQL client for any operations — [learn more](/libsql#encryption-at-rest).
## Concurrency
By default, the client performs up to `20` concurrent requests. You can set this option to a higher
number to increase the concurrency limit. You can also set this option to `undefined` to disable concurrency
completely:
```ts {4}
import { createClient } from "@libsql/client";
const client = createClient({
concurrency: 10,
});
```
## Response
Each method listed below returns a `Promise<ResultSet>`:
| Property          | Type                          | Description                                                                                                        |
| ----------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `rows`            | `Array<Row>`                  | An array of Row objects containing the row values, empty for write operations                                      |
| `columns`         | `Array<string>`               | An array of strings with the names of the columns in the order they appear in each Row, empty for write operations |
| `rowsAffected`    | `number`                      | The number of rows affected by a write statement, `0` otherwise                                                    |
| `lastInsertRowid` | `bigint         \| undefined` | The ID of a newly inserted row, or `undefined` if there is none for the statement                                  |
## Simple query
You can pass a string or object to `execute()` to invoke a SQL statement:
<CodeGroup>
```ts String
const result = await client.execute("SELECT * FROM users");
```
```ts Object
const result = await client.execute({
sql: "SELECT * FROM users WHERE id = ?",
args: [1],
});
```
</CodeGroup>
## Placeholders
libSQL supports the use of positional and named placeholders within SQL statements:
<CodeGroup>
```ts Positional
const result = await client.execute({
sql: "SELECT * FROM users WHERE id = ?",
args: [1],
});
const result = await client.batch(
[
{
sql: "INSERT INTO users VALUES (?)",
args: ["Iku"],
},
],
"write",
);
```
```ts Named
const result = await client.execute({
sql: "INSERT INTO users VALUES (:name)",
args: { name: "Iku" },
});
const result = await client.batch(
[
{
sql: "INSERT INTO users VALUES (:name)",
args: { name: "Iku" },
},
],
"write",
);
```
</CodeGroup>
<br />
<Info>
libSQL supports the same named placeholder characters as SQLite — `:`, `@` and `$`.
</Info>
## Transaction Modes
| Mode       | SQLite command               | Description                                                                                                                                                                                        |
| ---------- | ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `write`    | `BEGIN IMMEDIATE`            | The transaction may execute statements that read and write data. Write transactions executed on a replica are forwarded to the primary instance, and can't operate in parallel.                    |
| `read`     | `BEGIN TRANSACTION READONLY` | The transaction may only execute statements that read data (select). Read transactions can occur on replicas, and can operate in parallel with other read transactions.                            |
| `deferred` | `BEGIN DEFERRED`             | The transaction starts in read mode, then changes to write as soon as a write statement is executed. This mode change may fail if there is a write transaction currently executing on the primary. |
## Batch Transactions
A batch consists of multiple SQL statements executed sequentially within an implicit transaction. The backend handles the transaction: success commits all changes, while any failure results in a full rollback with no modifications.
```ts
const result = await client.batch(
[
{
sql: "INSERT INTO users VALUES (?)",
args: ["Iku"],
},
{
sql: "INSERT INTO users VALUES (?)",
args: ["Iku 2"],
},
],
"write",
);
```
## Interactive Transactions
Interactive transactions in SQLite ensure the consistency of a series of read and write operations within a transaction's scope. These transactions give you control over when to commit or roll back changes, isolating them from other client activity.
| Method       | Description                                                         |
| ------------ | ------------------------------------------------------------------- |
| `execute()`  | Similar to `execute()` except within the context of the transaction |
| `commit()`   | Commits all write statements in the transaction                     |
| `rollback()` | Rolls back the entire transaction                                   |
| `close()`    | Immediately stops the transaction                                   |
<CodeGroup>
```ts Rollback Usage
try {
const userId = "user123";
const withdrawalAmount = 500;
const transaction = await client.transaction("write");
const balanceResult = await transaction.execute({
sql: "SELECT balance FROM accounts WHERE userId = ?",
args: [userId],
});
const currentBalance = balanceResult.rows[0]["balance"] as number;
if (currentBalance >= withdrawalAmount) {
await transaction.execute({
sql: "UPDATE accounts SET balance = balance - ? WHERE userId = ?",
args: [withdrawalAmount, userId],
});
} else {
console.log("Insufficient funds");
await transaction.rollback();
return;
}
await transaction.commit();
} catch (e) {
console.error(e);
}
```
```ts Batch Usage
let transaction: Transaction | null = null;
try {
const records = [
{ name: "Alice", age: 30 },
{ name: "Bob", age: 25 },
{ name: "Charlie", age: 35 },
];
transaction = await client.transaction("write");
for (const record of records) {
await transaction.execute({
sql: "INSERT INTO people (name, age) VALUES (?, ?)",
args: [record.name, record.age],
});
}
await transaction.commit();
} catch (e) {
console.error(e);
if (transaction) await transaction.rollback();
}
```
```ts Conditional Usage
try {
const productId = "prod456";
const newPrice = 150;
const transaction = await client.transaction("write");
const productResult = await transaction.execute({
sql: "SELECT price FROM products WHERE productId = ?",
args: [productId],
});
const currentPrice = productResult.rows[0]["price"] as number;
if (currentPrice > newPrice) {
await transaction.execute({
sql: "UPDATE products SET price = ? WHERE productId = ?",
args: [newPrice, productId],
});
} else {
console.log("New price is not lower than current price");
await transaction.rollback();
return;
}
await transaction.commit();
} catch (e) {
console.error(e);
}
```
</CodeGroup>
<br />
<Warning>
Interactive transactions in libSQL lock the database for writing until
committed or rolled back, with a 5-second timeout. They can impact performance
on high-latency or busy databases.
</Warning>
## ATTACH
You can attach multiple databases to the current connection using the `ATTACH` attachment:
```ts
import { createClient } from "@libsql/client";
const client = createClient({
url: process.env.TURSO_DATABASE_URL,
authToken: process.env.TURSO_AUTH_TOKEN,
});
const txn = await db.transaction("read");
await txn.execute('ATTACH "<database-id>" AS attached');
const rs = await txn.execute("SELECT * FROM attached.users");
```
<Info>
Make sure to [allow `ATTACH`](/cli/db/config/attach/allow) and create a token
with the permission to attach a database — [learn
more](/features/attach-database)
</Info>
# Support
Source: https://docs.turso.tech/support
We're always here to help.
<CardGroup cols={2}>
<Card title="Getting Started" href="/quickstart" icon="play">
If you're new to Turso, the easiest way to get started is with this quickstart.
</Card>
<Card title="Discord" href="https://discord.gg/turso" icon="discord">
Show off what you're working on, ask for help, and chat with the community.
</Card>
<Card title="Security" href="mailto:security@turso.tech" icon="envelope">
If you spot something that doesn't look right, or you've discovered a security related bug or issue, let us know.
</Card>
<Card title="FAQs" href="https://turso.tech/pricing#faqs" icon="question">
If you have a question about your account or billing, you'll find answers to most questions on our website.
</Card>
</CardGroup>